---
title: "Figures for White et al. 2017"
author: "Richard White"
date: "24th January 2017"
output: html_document
---

```{r load_libraries, include=FALSE, message=FALSE }
# checks whether packages are installed and trys to install them if not
packages <-  c("knitr", "rprojroot", "ggplot2", "ggbio", "reshape2", 
               "scales", "GenomicFeatures", "plyr", "RColorBrewer",
               "cba", "topGO", "grid", "gridExtra", "Rgraphviz", "biomaRt", "htmlTable",
               "DESeq2", "genefilter", "qvalue", "rgl", "R2HTML" )
for( package in packages ){
  if(!require( package, character.only = TRUE )){
    install.packages( package )
    require( package, character.only = TRUE )
  }
}
```

```{r knitr_options, include=FALSE, message=FALSE }
opts_chunk$set( fig.width=9, fig.height=6, include=FALSE, echo=FALSE  )
```

```{r set_up_plot_list, eval = FALSE}
plotList <- list()
add_to_plot_list <- function( plotList, plot, filename ){
  index <- length(plotList) + 1
  plotList[[index]] <- list( plot = plot, file = filename )
  return( plotList )
}
figNum <- 1
```

```{r get_root}
rootPath <- find_root(is_rstudio_project)
for( dir in c('plots', 'output', 
              file.path('output', 'topgo'),
              file.path('output', 'topgo', 'maxByStage'),
              file.path('output', 'topgo', '0.94-e85'),
              file.path('output', 'biolayout-clusters-files') ) ){
  dirPath <- file.path( rootPath, dir )
  if( !dir.exists(dirPath) ){
    dir.create( dirPath )
  }
}

# set version of Ensembl database
ensVersion <- '85'
geneIdColumnName <- paste0('e', ensVersion, '.Ensembl.Gene.ID')
```

```{bash transcriptInfo}
###################################
## GET ANNOTATION INFO
###################################

# Later on we will need information on transcript lengths as well as gene names for gene ids
# Check for existence of GTF file
# If not download it from Ensembl

# check whether the gtf file exists
# To change the version of the Ensembl annotation, change the ensVersion variable
ensVersion='85'
gtfFile="Danio_rerio.GRCz10.$ensVersion.gtf"
gtfLink="ftp://ftp.ensembl.org/pub/release-$ensVersion/gtf/danio_rerio/$gtfFile.gz"

# check for transcripts file
if [[ ! -e $gtfFile ]]
then
  # download and unzip GTF file
  curl -O $gtfLink
  gunzip $gtfFile.gz
  mv $gtfFile dataFiles/
fi
```

```{r loadRNASeqData}
DeseqDataFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'DESeq.zfs.rnaseq.grcz10.RData')
if( file.exists(DeseqDataFile) ){
  load(DeseqDataFile)
} else {
  dataFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'zfs-rnaseq-grcz10.tsv')
  if( !file.exists(dataFile) ){
    stop("RNA-seq counts data file is not present! Please download from figshare. See README.")
  }
  rnaseqData <- read.table(dataFile, sep="\t", header=TRUE, quote = "\"")
  # data contains columns including gene information and then a column of counts for each sample
  # countData is just the counts columns
  countData <- rnaseqData[ , grepl("count", colnames(rnaseqData) ) ]
  colnames(countData) <- gsub(".count", "", colnames(countData) )
  rownames(countData) <- rnaseqData[[geneIdColumnName]]
  
  # the samples file contains 7 columns
  # sample: internal sample name used for sequencing
  # public_name: sample name in ENA
  # accession_number: ENA sample accession number
  # condition: ZFS stage id for the stage that the sample was collected at
  # stage: stage name from ZFIN.org
  # stageName: shorted name with prefixes removed
  # sampleName: sample name composed of stage name and arbitrary number
  rnaseqSampleFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'zfs-rnaseq-sampleInfo.tsv')
  rnaseqSampleInfo <- read.table(rnaseqSampleFile, sep="\t", header=TRUE,
                           colClasses = c('character', 'character', 'character', 
                                          'factor', 'factor', 'factor', 'character' ) )
  
  rnaseqSampleInfo$stageName <- factor( rnaseqSampleInfo$stageName,
                                        levels = unique(rnaseqSampleInfo$stageName) )
  rnaseqSampleInfo$sampleName <- factor( rnaseqSampleInfo$sampleName,
                                         levels = unique(rnaseqSampleInfo$sampleName) )

  # define groups for colouring
  stageGroupNames <- c("pre-ZGA", "Gastrula", "Somitogenesis", "Prim-stages", "2-5dpf")
  colourGroup <-
    c(rep(paste0(stageGroupNames[1], '-', 1:4), each = 5),
      rep(paste0(stageGroupNames[2], '-', 1:4), each = 5),
      rep(paste0(stageGroupNames[3], '-', 1:3), each = 5),
      rep(paste0(stageGroupNames[4], '-', 1:3), each = 5),
      rep(paste0(stageGroupNames[5], '-', 1:4), each = 5) )
  rnaseqSampleInfo$colourGroup <- factor( colourGroup,
                                          levels = unique(colourGroup) )
  rnaseqSampleInfo$stageGroup <- 
    factor( gsub("-[1-5]$", "", colourGroup),
            levels = c("pre-ZGA", "Gastrula", "Somitogenesis", "Prim-stages", "2-5dpf") )
  
  # set sample names to be row names of sample info
  rownames(rnaseqSampleInfo) <- rnaseqSampleInfo$sampleName

  # order count data in stage order
  colorder <- sapply( rnaseqSampleInfo$sample, 
                      function(x){ which( colnames(countData) == x ) } )
  countData <- countData[ , colorder ]

  # relabel colnames with sample names
  colnames(countData) <- rownames(rnaseqSampleInfo)

  # make DESeq object and do rlog transform
  dds <- DESeqDataSetFromMatrix(countData, rnaseqSampleInfo, design = ~ condition)
  
  # add metadata
  featureData <- rnaseqData[ , !grepl("count", colnames(rnaseqData) ) ]
  mcols(dds) <- DataFrame(mcols(dds), featureData)
  
  dds <- estimateSizeFactors(dds)
  ddsRlog <- rlogTransformation(dds, blind=TRUE)
  
  # save objects to file for reloading
  save(rnaseqData, countData, rnaseqSampleInfo, dds, ddsRlog, file=DeseqDataFile)
}

# create sample strip image
# create colour-blind friendly palette
colourBlindHues <- c(
  orange = 41,
  blue_green = 164,
  yellow = 56,
  blue = 202,
  purple = 326,
  vermillion = 27,
  black = 0
)

# palette with changing value
colourPalette <- 
  hsv(h = c( rep(colourBlindHues[1]/360, 4),
             rep(colourBlindHues[2]/360, 4),
             rep(colourBlindHues[3]/360, 3),
             rep(colourBlindHues[4]/360, 3),
             rep(colourBlindHues[5]/360, 4) ), 
      v = c(seq(1,0.55,-0.15),
            seq(1,0.55,-0.15),
            seq(1,0.55,-0.225),
            seq(1,0.55,-0.225),
            seq(1,0.55,-0.15)
      ),
      s = c(rep(1, 14), 0.6, rep(1,3)) 
  )
names(colourPalette) <- levels(rnaseqSampleInfo$stageName)
# output colours
write.table(
  data.frame(
    row.names = levels(rnaseqSampleInfo$condition),
    stage = levels(rnaseqSampleInfo$stageName),
    stageGroup = ddply(rnaseqSampleInfo, .(condition, stageGroup), summarise, sum = length(condition) )$stageGroup,
    colour = colourPalette
  ), 
  file.path(rootPath, 'output', 'zfs-stages-palette.dark.txt'), 
  quote = FALSE, sep = "\t", col.names = NA
)
# set shape palette for later as well
shapePalette <- c(15:18,7)

sampleStrip <- 
  ggplot(data=rnaseqSampleInfo, aes(x=sampleName, y=1, fill=stageName) ) + 
  geom_tile() + 
  scale_fill_manual(values = colourPalette) + 
  guides(fill=FALSE) +
  theme_void()

# this isn't quite right. it has some white space around that I can't figure out how to get rid of.
svg(filename = file.path(rootPath, 'plots', 'sample-strip.svg'),
    width = 3.5, height = 0.2)
print(sampleStrip)
dev.off()

```

```{bash create_svg_files}
# wrote a quick script to produce the same SVG without the white space
# create svg using colours in palette file
cut -f4 output/zfs-stages-palette.dark.txt | grep -v colour | \
perl -lane 'BEGIN{ @colours = ();} { push @colours, $F[0]; } 
END{ print join(q{}, q{perl sample_strip.pl --colours "}, 
join(q{" --colours "}, @colours ), q{"} ); }' | sh > plots/sample_strip.dark.svg

# make a version with black lines around the rectangles
cut -f4 output/zfs-stages-palette.dark.txt | grep -v colour | \
perl -lane 'BEGIN{ @colours = ();} { push @colours, $F[0]; } 
END{ print join(q{}, q{perl sample_strip.pl --colours "}, 
join(q{" --colours "}, @colours ), q{" --lines} ); }' | sh > plots/sample_strip-lines.dark.svg
```

## Fig. S1

### Fig. S1a

#### Reads Mapped

```{r reads_mapped_rnaseq}
# the data on Mapped reads comes from the QoRTs package and is present in summary table file
# the READ_PAIR_OK category are read pairs that are properly paired and uniquely mapped

# RNA-Seq data
rnaseqQortsDataFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'qorts-summary-table.txt' )
rnaseqQortsData <- read.table(file=rnaseqQortsDataFile, sep="\t", header=TRUE)
# subset to READ_PAIR_OK
rnaseqQortsData <- rnaseqQortsData[ rnaseqQortsData$FIELD == "READ_PAIR_OK", ]
# reshape data
rnaseqQortsData.m <- melt(rnaseqQortsData, id.vars="FIELD", variable.name="sample")
# remove FIELD column
rnaseqQortsData.m <- rnaseqQortsData.m[ , !grepl("FIELD", colnames(rnaseqQortsData.m)) ]

rnaseqQortsData.m$sampleType <- factor( rep('RNA-Seq', nrow(rnaseqQortsData.m) ),
                                   levels = c('RNA-Seq', 'DETCT single', 'DETCT pool') )

# merge molten data and sample info
rnaseqQortsData.stage.m <- merge(rnaseqQortsData.m, rnaseqSampleInfo)

# numGenesPlotRNAseq <- ggplot(data = rnaseqGDData, aes(x = stageName, y = genes, fill = stageName) ) +
#   geom_boxplot(outlier.shape=NA, size = 0.2 ) +
#   scale_fill_manual(values = colourPalette) +
#   labs(x="Stage", y=paste0("Genes Detected (>= ", rnaseqTpmThreshold, " TPM)") ) +
#   theme_minimal() +
#   theme( axis.text.x = element_text(colour = "black", angle = 90, vjust = 0.4, hjust = 1) )

# box plot of just RNA-seq data
readPairsBoxPlot <- ggplot(data = rnaseqQortsData.stage.m, aes(x = stageName, y = value) ) +
  geom_boxplot(outlier.shape=NA, size = 0.2 ) +
  scale_y_continuous(labels = function(x){ sprintf('%.0f', x/1000000) }) +
  labs(x="Stage", y=expression(paste('Mapped Read Pairs (x ', 10^6, ')') ) ) +
  theme_minimal() +
  theme( axis.text.x = element_text(colour = "black", angle = 90, vjust = 0.4, hjust = 1) )

print(readPairsBoxPlot)

# Plot points and bar for mean for just RNA-seq data
# ggplot(data = rnaseqQortsData.stage.m, aes(x = stageName, y = value, colour = sampleType) ) +
# 	geom_jitter( height = 0, width = 0.1 ) +
# 	stat_summary(fun.y = "mean", fun.ymin = "mean",
#                 fun.ymax="mean", geom = "crossbar", width = 0.5 ) +
# 	scale_y_continuous( labels = function(x){ sprintf('%.0f', x/1000000) } ) +
# 	labs(x="Stage", y="Mapped Read Pairs (x1000000)") +
#     theme_minimal() +
#     theme( axis.text.x = element_text( colour = "black", angle = 90, hjust = 1 ),
#             axis.text.y = element_text( size = rel(0.8)),
#             axis.title.y = element_text( size = rel(0.8))
#     )


# # add to plot list
# plotList <- add_to_plot_list( plotList, 
#                               readPairsBoxPlot, file.path(rootPath, 'plots', 'Fig.S1a.pdf') )

# output to eps
postscript(file = file.path(rootPath, 'plots', 'Fig.S1a.eps'),
           width= 7, height = 5, paper = "special")
print(readPairsBoxPlot)
dev.off()

```

```{r getTranscriptInfo}
# check for the existence of Transcript info
# Ensembl version is set at the top of the script
TranscriptsFile <- file.path(rootPath, 'dataFiles', 'rnaseq', paste0('Danio_rerio.e', ensVersion, '.transcript.lengths.tsv') )
gtfFile <- file.path(rootPath, paste0('dataFiles', 'Danio_rerio.GRCz10.', ensVersion, '.gtf') )

if( file.exists(TranscriptsFile) ){
  TxInfo <- read.table(file=TranscriptsFile, sep="\t", row.names = 1)
  TxLengths <- TxInfo[[1]]
  names(TxLengths) <- rownames(TxInfo)
} else{
  # check for the existence of TxDb file
  TxDbFile <- file.path(rootPath, 'dataFiles', paste0('Danio_rerio.GRCz10.', ensVersion, '.db') )
  if( file.exists( TxDbFile ) ){
    txdb <- loadDb( TxDbFile )
  } else {
    # make TxDb from GFF file
    txdb <- makeTxDbFromGFF(
      gtfFile, format="gtf",
      dataSource = "Ensembl",
      organism = "Danio rerio",
      taxonomyId = 7955
    )
    # save to db file
    saveDb( txdb, TxDbFile )
  }
  # calculate lengths of transcripts
  exonsByGene <- exonsBy(txdb, by="gene")
  TxLengths <- sapply(exonsByGene, 
                      function( gene ){ sum( width( reduce(unlist(gene)) ) ) }
  )
  write.table(TxLengths, file=TranscriptsFile, 
              row.names=TRUE, sep="\t", quote=FALSE, col.names = FALSE)
}
```

```{r getInsertSizes}
# get InsertSize_Mean from QoRTs output
qortsSummaryFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'qorts-summary-table.txt')
qortsSummary <- read.table(qortsSummaryFile, sep="\t", 
                           header=TRUE, row.names = 1 )
insertSizes <- unlist(qortsSummary["InsertSize_Mean",])

# match up sample names
names(insertSizes) <- sapply(names(insertSizes), 
 function(sample){ rownames(rnaseqSampleInfo)[ rnaseqSampleInfo$sample == sample ] } 
)
insertSizes <- insertSizes[ rownames(colData(dds)) ]
```

```{r countsToTpm}
#' This function is from https://gist.github.com/slowkow/c6ab0348747f86e2748b#file-counts_to_tpm-r
#' Convert counts to transcripts per million (TPM).
#' 
#' Convert a numeric matrix of features (rows) and conditions (columns) with
#' raw feature counts to transcripts per million.
#' 
#'    Lior Pachter. Models for transcript quantification from RNA-Seq.
#'    arXiv:1104.3889v2 
#'    
#'    Wagner, et al. Measurement of mRNA abundance using RNA-seq data:
#'    RPKM measure is inconsistent among samples. Theory Biosci. 24 July 2012.
#'    doi:10.1007/s12064-012-0162-3
#'    
#' @param counts A numeric matrix of raw feature counts i.e.
#'  fragments assigned to each gene.
#' @param featureLength A numeric vector with feature lengths.
#' @param meanFragmentLength A numeric vector with mean fragment lengths.
#' @return tpm A numeric matrix normalized by library size and feature length
counts_to_tpm <- function(counts, featureLength, meanFragmentLength) {
  
  # Ensure valid arguments.
  stopifnot(length(featureLength) == nrow(counts))
  stopifnot(length(meanFragmentLength) == ncol(counts))
  
  # Compute effective lengths of features in each library.
  effLen <- do.call(cbind, lapply(1:ncol(counts), function(i) {
    featureLength - meanFragmentLength[i] + 1
  }))
  
  # Exclude genes with length less than the mean fragment length.
  idx <- apply(effLen, 1, function(x) min(x) > 1)
  counts <- counts[idx,]
  effLen <- effLen[idx,]
  featureLength <- featureLength[idx]
  
  # Process one column at a time.
  tpm <- do.call(cbind, lapply(1:ncol(counts), function(i) {
    rate = log(counts[,i]) - log(effLen[,i])
    denom = log(sum(exp(rate)))
    exp(rate - denom + log(1e6))
  }))

  # Copy the column names from the original matrix.
  colnames(tpm) <- colnames(counts)
  return(tpm)
}
```

```{r create_and_filter_tpm}
tpm <- counts_to_tpm(counts(dds), TxLengths, insertSizes)

# divide data up by Gene and then Stage
tpmByGeneList <- split.data.frame(tpm, 
                                  factor(rownames(tpm), 
                                          levels = rownames(tpm))
                                  )
tpmByGeneByStageList <- lapply(tpmByGeneList,
                               function(x){ 
                                 split.data.frame(t(x), rnaseqSampleInfo$stageName) } )

# filter to genes with non-zero TPM in all replicates at at least one stage
tpmThreshold <- 0
genesAboveThreshold <- sapply( tpmByGeneByStageList,
                               function(geneByStageList){
                                 any( sapply(geneByStageList, 
                                             function(x){ all(x > tpmThreshold) } ) )
                               }
                        )
tpmFilt <- tpm[genesAboveThreshold, ]

# join to annotation and output for expression file
tpmAnno <- merge( mcols(dds), tpmFilt, 
                  by.x = c('e85.Ensembl.Gene.ID'),
                  by.y = 0 )
rownames(tpmAnno) <- tpmAnno$e85.Ensembl.Gene.ID
tpmAnno <- tpmAnno[ order(tpmAnno$Chr, tpmAnno$Start), ]
outFilename <- file.path(rootPath, 'output', 'zfs-grcz10.tpm.tsv')
write.table(tpmAnno, file = outFilename, quote = FALSE, sep = "\t",
            col.names = FALSE, row.names = FALSE)

# make tpm matrix including every gene.
# have NA for genes that do not have tpms due to transcript size
tpmAll <- matrix(rep(NA, 2889450), nrow = 32105)
genes_in_chr_order <- as.character( mcols(dds)[['e85.Ensembl.Gene.ID']][ order(mcols(dds)$Chr, mcols(dds)$Start) ] )
rownames(tpmAll) <- genes_in_chr_order
for( gene in genes_in_chr_order ){
  if( any(rownames(tpm) == gene ) ){
    tpmAll[gene,] <- tpm[gene,]
  }
}

```

### Fig. S1b

#### Genes detected

```{r genes_detected_plot, include=TRUE}
rnaseqTpmThreshold <- 1
rnaseqGenesDetectedByStage <- apply(tpmFilt, 2, function(col){ sum(col >= rnaseqTpmThreshold) } )
rnaseqGenesDetected.m <- melt(rnaseqGenesDetectedByStage)
rnaseqGenesDetected <- data.frame(
  sampleName = rownames(rnaseqGenesDetected.m),
  genes = rnaseqGenesDetected.m$value
)
rnaseqGDData <- merge(rnaseqGenesDetected, rnaseqSampleInfo)

numGenesPlotRNAseq <- ggplot(data = rnaseqGDData, aes(x = stageName, y = genes) ) +
  geom_boxplot(outlier.shape=NA, size = 0.2 ) +
  labs(x="Stage", y=paste0("Genes Detected (>= ", rnaseqTpmThreshold, " TPM)") ) +
  theme_minimal() +
  theme( axis.text.x = element_text(colour = "black", angle = 90, vjust = 0.4, hjust = 1) )

print(numGenesPlotRNAseq)

# output to eps
postscript(file = file.path(rootPath, 'plots', 'Fig.S1b.eps'),
           width= 7, height = 5, paper = "special")
print(numGenesPlotRNAseq)
dev.off()

```

### Fig. S1c

#### Distribution of mean TPM by stage

```{r mean_tpm_dist_by_stage, include = TRUE}
# divide data up by Gene and then Stage
tpmFiltByGeneList <- 
  split.data.frame(tpmFilt, 
                    factor(rownames(tpmFilt), 
                    levels = rownames(tpmFilt))
  )
tpmFiltByGeneByStageList <- lapply(tpmFiltByGeneList,
                               function(x){ 
                                 split.data.frame(t(x), rnaseqSampleInfo$stageName) } )

tpmFiltByStageList <- 
  split.data.frame(t(tpmFilt), rnaseqSampleInfo$stageName)

# filter ones where all samples are 0 for that stage
meanTpmFiltByStage <- 
  do.call('rbind',
    lapply(seq_len(length(tpmFiltByStageList)),
         function(i){
           tpmFiltByStage <- tpmFiltByStageList[[i]]
           aboveThreshold <- apply(tpmFiltByStage, 2, function(col){ !all(col == 0) } )
           means <- colMeans(tpmFiltByStage)[aboveThreshold]
           return(
             data.frame(
               stage = rep(names(tpmFiltByStageList)[i], length(means)),
               gene_id = names(means),
               meanExpr = means
             )
           )
         }
    )
  )

# work out tallest bar on a histogram
# calc lowest and highest log2 category
xLowLim <- floor(log2(min(meanTpmFiltByStage$meanExpr)))
xHighLim <- ceiling(log2(max(meanTpmFiltByStage$meanExpr)))
# cut mean expression column and count up numbers in bins
meanTpmFiltByStage$binned_data <- cut(log2(meanTpmFiltByStage$meanExpr), breaks = seq(xLowLim,xHighLim,1))
bin_counts <- ddply(
    meanTpmFiltByStage, .(stage, binned_data),
    summarize, bin_size = length(binned_data)
)
# work out total genes detected per stage
numGenes <- ddply(
    meanTpmFiltByStage, .(stage),
    summarize, numGenes = paste0( 'Total genes = ', length(stage) )
  )
midRange <- floor(2^(xHighLim - (xHighLim - xLowLim)/2)) # place the text in the middle of the x axis
maxBarHeight <- (ceiling(max(bin_counts$bin_size)/1000) + 0.2)*1000 # put the text just above the nearest 1000 above the tallest bar
numGenes$x = rep(midRange, nrow(numGenes) )
numGenes$y = rep(maxBarHeight, nrow(numGenes) )

genesDistPlot <- ggplot(data=meanTpmFiltByStage, aes(meanExpr) ) +
  geom_histogram( breaks = seq(xLowLim,xHighLim,1), closed = 'right' ) +
  geom_text( data = numGenes, aes(x, y, label=numGenes), size = 2 ) +
  facet_wrap( ~ stage, nrow = 3, scales = "free_x" ) +
  labs(x="Mean Expression (log2[TPM])", y="Frequency",
       title="Distribution of gene expression by stage") +
  theme_minimal() + 
  theme( strip.background = element_rect(fill="grey90", colour = "white"),
         panel.spacing.y = unit(0.5, units = 'cm'),
         axis.text.x = element_text( size = 6, angle = 0, debug = FALSE)
         ) + 
  scale_x_continuous(trans = log2_trans(),
                     labels = 
                       function(log2breaks){
    log2labels <- vector('list', length = length(log2breaks))
    # log2breaks <- c(NA,-4, 3, 10, 17)
    for( i in seq_len(length(log2breaks)) ){
      exponent <- as.character(log2(log2breaks[i]))
      if(is.na(exponent)){
        log2labels[[i]] <- NA
      } else {
        log2labels[[i]] <- bquote(2^ ~ .(exponent))
      }
    }
    # print(log2labels)
    return(log2labels)
  } )

# print(genesDistPlot)
```

```{r tpm_dist_hist}
# output to eps
postscript(file = file.path(rootPath, 'plots', 'Fig.S1c.eps'),
           width= 7, height = 5, paper = "special")
print(genesDistPlot)
dev.off()
```

### Fig 1b

#### Sample Correlation Matrix

```{r fig1b, include=TRUE}
# 
# sampleCor <- cor(tpmFilt)
# 
# # melt for ggplot
# sampleCor.m <- melt(sampleCor)
# # reverse levels of y axis variable so that it plots sensibly
# sampleCor.m$Var2 <- factor( sampleCor.m$Var2,
#                             levels = rev(levels(sampleCor.m$Var2))
#   )
# # plot correlation matrix
# sampleCorHeatmap <- ggplot(data = sampleCor.m) + 
#   geom_tile( aes( x = Var1, y = Var2, fill = value ),
#                colour = "grey60" ) + 
#   scale_fill_gradientn( colours = c("blue", "yellow", "red"),
#                         guide = guide_colorbar(title = "Correlation\nCoefficient\n(Pearson)") ) + 
#   theme_void() + theme( legend.position="right",
#                         legend.title = element_text(colour="black" ) )
# 
# 
# plotList <- add_to_plot_list( plotList, 
#                               sampleCorHeatmap, file.path(rootPath, 'plots', 'Figure.1d.pdf') )
# 
# print(sampleCorHeatmap)

# create Spearmansample correlation matrix
sampleCor_spearman <- cor(tpmFilt, method = "spearman")
sampleCor_spearman.m <- melt(sampleCor_spearman)
sampleCor_spearman.m$Var2 <- factor( sampleCor_spearman.m$Var2, levels = rev(levels(sampleCor_spearman.m$Var2)) )

sampleCor_spearman_heatmap <- ggplot(data = sampleCor_spearman.m) +
  geom_tile( aes( x = Var1, y = Var2, fill = value), colour = "grey60" ) +
  scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                        guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)") ) +
  theme_void() + theme( legend.position="right", legend.title = element_text(colour="black" ) )

# plot as eps
# plot one with the legend and one without to get a square plot of the matrix
postscript(file.path(rootPath, 'plots', 'Fig.1b.eps'),
           width = 6, height = 5)
print(sampleCor_spearman_heatmap)
dev.off()

postscript(file.path(rootPath, 'plots', 'Fig.1b.no_legend.eps'),
           width = 5, height = 5)
print(sampleCor_spearman_heatmap + theme(legend.position = 'none'))
dev.off()

# other colour schemes
# pdf(file=file.path(rootPath, 'plots', 'sample_cor_spearman.pdf'))
# 
# ggplot(data = sampleCor_spearman.m) + 
#   geom_tile( aes( x = Var1, y = Var2, fill = value), colour = "grey60" ) +  
#   scale_fill_viridis(guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)") ) + 
#   theme_void() + theme( legend.position="right", legend.title = element_text(colour="black" ) )
# 
# ggplot(data = sampleCor_spearman.m) + 
#   geom_tile( aes( x = Var1, y = Var2, fill = value), colour = "grey60" ) +  
#   scale_fill_viridis(option="magma", guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)") ) + 
#   theme_void() + theme( legend.position="right", legend.title = element_text(colour="black" ) )
# dev.off()


```

```{r long_pec_vs_early_stages, eval=FALSE}
# This is to look at what is driving the difference between Pearson and 
# Spearman correlation coefficients
# One gene that is very highly expressed (ENSDARG00000080337) 
# has a disproportionate effect on the Pearson coefficient

# plot tpms against each other for every sample against long-pec-5
# to look at what is influencing Pearson
pdf(file= file.path(rootPath, 'plots', 'tpm_scatterplots.pdf') )
sample_names <- as.character(rnaseqSampleInfo$sampleName)
for(i in seq_len(length(sample_names))){
  for(j in seq_len(length(sample_names))){
    if(j <= i){
      next
    } else {
      sample_1 <- sample_names[i]
      sample_2 <- sample_names[j]
      plot_data <- data.frame(
        gene_id = row.names(tpmFilt),
        tpm_y = tpmFilt[, sample_1],
        tpm_x = tpmFilt[, sample_2]
      )
      print( 
        ggplot(data = plot_data, aes(x = tpm_x, y = tpm_y)) + geom_point() +
          labs(x = sample_2, y = sample_1) + 
          lims(x = c(0,260000), y = c(0,260000))
        )
    }
  }
}
dev.off()

# Pearson is skewed by one highly expressed gene
which( tpmFilt[, '1-cell-1'] > 200000 )
# ENSDARG00000080337 
#              15809

# redo pearson without that gene
tpmFiltnoMT <- tpmFilt[ !(rownames(tpmFilt) == 'ENSDARG00000080337'), ]

pearson_noMT <- cor(tpmFiltnoMT)

# melt for ggplot
pearson_noMT.m <- melt(pearson_noMT)
# reverse levels of y axis variable so that it plots sensibly
pearson_noMT.m$Var2 <- factor( pearson_noMT.m$Var2,
                            levels = rev(levels(pearson_noMT.m$Var2))
  )
# plot correlation matrix
pearson_noMTHeatmap <- ggplot(data = pearson_noMT.m) + 
  geom_tile( aes( x = Var1, y = Var2, fill = value ),
               colour = "grey60" ) + 
  scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                        guide = guide_colorbar(title = "Correlation\nCoefficient\n(Pearson)") ) + 
  theme_void() + theme( legend.position="right",
                        legend.title = element_text(colour="black" ) )

# looks more like the Spearman matrix
pdf(file.path(rootPath, 'plots', 'samplecor.pearson.noENSDARG00000080337.pdf'))
print(pearson_noMTHeatmap)
dev.off()

```

### Fig 1d

```{r pca}
# set up constants
varPCThreshold <- 1
varRegionThreshold <- 0.01
sampleNames <- FALSE

#' PCA_plot
#' function to plot arbitrary PCs against each other
#' 
#' This function takes the object produced by prcomp and plots a scatterplot of
#'   two of the principal components against each other. 
#'    
#' @param pca The object returned by prcomp
#' @param propVarPC A vector of the proportions of variance explained by each component
#' @param firstPC the index of the first compoenent to plot
#' @param secondPC optionally the index of the second component to plot
#'    if NULL, then it defaults to firstPC + 1
#' @param DESeqTrans The DESeqTrans object used to create the PCA
#' @param sampleNames a character vector of optional sample names to be plotted next to the points
#'
#' @return plot A ggplot2object of the scatterplot
#'
PCA_plot <- function( pca, propVarPC, firstPC, secondPC = NULL, 
                      DESeqTrans, sampleNames = NULL, 
                      colourPalette = NULL, shapePalette = NULL, size = 2 ){
  secondPC <- ifelse(is.null(secondPC), firstPC + 1, secondPC )
  # make a data frame for plotting from
  d <- data.frame(first = pca$x[,firstPC], second = pca$x[,secondPC],
                  Stage = colData(DESeqTrans)$stageName,
                  StageGroup = colData(DESeqTrans)$stageGroup)
  if( !is.null( sampleNames ) ){
    d$name <- sampleNames
  }
  # # choose plot colours
  if ( is.null(colourPalette) ) {
    numLevels <- nlevels(d$Stage)
    ord1 <- seq(1,numLevels,2)
    ord2 <- seq(2,numLevels,2)
    colourPalette <- hue_pal()(numLevels)[ order(c(ord1,ord2)) ]
  }
  if ( is.null(shapePalette) ) {
    shapes = c(15:17,23,9,4,3,7)
    numLevels <- nlevels(d$StageGroup)
    shapePalette <- shapes[seq_len(numLevels)]
  }
  pcaPlot <- ggplot(data = d) +
    geom_point( aes(x = first, y = second, colour = Stage, fill = Stage, shape = StageGroup), size = size, stroke = 0.2 ) + 
    scale_colour_manual(values = colourPalette) + 
    scale_fill_manual(values = colourPalette) + 
    scale_shape_manual(values = shapePalette) +
    xlab(paste0("PC", firstPC, ": ", round(propVarPC[firstPC] * 100, 1),
                "% variance")) +
    ylab(paste0("PC", secondPC, ": ", round(propVarPC[secondPC] * 100, 1),
                "% variance")) + theme_minimal()
  
  if( !is.null( sampleNames ) ) {
    pcaPlot <- pcaPlot +
      geom_text(aes(label=sampleNames),
                hjust=0, vjust=0, size=4,
                show_guide=FALSE)
  }
  return(pcaPlot)
}

#' runPCA
#' A function to run principal component analysis (PCA) and create plots of the prinicipal components
#' plotted against each other
#' 
#' This functions takes a DESeqDataSet object and a DESeqTransform object and 
#'    a number of regions to use and runs PCA on the tramsformed counts
#'    and produces a plot of of each component plotted against the next
#'    for all components that explain over a certain amount of variance (varPCThreshold)
#'    
#' @param DESeqObj DESeqDataSet object
#' @param DESeqTransObj DESeqTransform object to use for PCA
#' @param regionCount integer, the number of regions to included when running the PCA
#'
#' @return list containing
#'    the object returned from prcomp
#'    a list of the PC plots
#'    a list of the regions contibuting to each component
#'
runPCA <- function( DESeqObj, DESeqTransObj, regionCount ){
  # run PCA on transformed data (DESeq2 Rlog or VST transforms)
  rv <- rowVars(assay(DESeqTransObj))
  # subset data to top regionCount most variable genes/regions
  select <- order(rv, decreasing=TRUE)[seq_len(min(regionCount, length(rv)))]
  pca <- prcomp(t(assay(DESeqTransObj)[select,]))
  # calculate the proportion of variance explained by each PC
  propVarPC <- pca$sdev^2 / sum( pca$sdev^2 )
  # calculate the proportion of variance contributed by each gene/region
  aload <- abs(pca$rotation)
  propVarRegion <- sweep(aload, 2, colSums(aload), "/")

  # Output regions contributing most to each PC
  # data <- as.data.frame(counts(DESeqObj, normalized=TRUE))
  data <- as.data.frame(counts(DESeqObj, normalized=FALSE))
  genesForPCsList <- vector('list', length = sum(propVarPC * 100 >= varPCThreshold))
  for (i in seq.int(sum(propVarPC * 100 >= varPCThreshold))) {
      data[select, "% variance explained"] <- propVarRegion[,i] * 100
      # order genes by amount of variance explained
      topData <- data[order(data$`% variance explained`, decreasing=TRUE),]
      topData <- topData[ topData[["% variance explained"]] >= varRegionThreshold, ]
      genesForPCsList[[i]] <- topData[ , !grepl('variance explained', colnames(data) ) ]
  }

  # Plot PCs in pairs
  plotList <- vector( "list", length = sum(propVarPC * 100 >= varPCThreshold) - 1 )
  for (i in seq.int(sum(propVarPC * 100 >= varPCThreshold) - 1)) {
      first <- i
      second <- i + 1
      pcaPlot <- PCA_plot( pca, propVarPC, first, second, 
                           DESeqTransObj, sampleNames = NULL,
                           colourPalette = colourPalette, shapePalette = shapePalette )
      plotList[[i]] <- pcaPlot
  }
  
  # graphics.off()
  return( 
    list(
      pca = pca,
      plots = plotList,
      PCData = genesForPCsList
    )
  )
}
```

```{r pca_all_regions}
# run PCA on all regions
regionCount <- nrow(rnaseqData)
pcaObj <- runPCA( dds, ddsRlog, regionCount )
pcaPlotList <- pcaObj$plots

```

#### PCA Plots (using all genes)

```{r pcs1_3_plots, include=TRUE, eval=FALSE}
# # fig.1e PC1 against 2
# plotList <- add_to_plot_list( plotList, 
#                               pcaPlotList[[1]] + theme( legend.position = "none" ), 
#                               file.path(rootPath, 'plots', 'Figure.1e.pdf') )
# print( pcaPlotList[[1]] + theme( legend.position = "none" ) )
# 
# # PC1 against 2, postscript
# PlotFile <- file.path(rootPath, 'plots', 'pca.PCs1-2.ps' )
# postscript(file=PlotFile, paper="special", width = 8, height = 8)
# print( pcaPlotList[[1]] + theme( legend.position = "none" ) )
# dev.off()
# 
# 
# # fig.1f PC1 against 3, with legend
# propVarPC <- pcaObj$pca$sdev^2 / sum( pcaObj$pca$sdev^2 )
# pc1_pc3Plot <- PCA_plot( pcaObj$pca, propVarPC, 1, secondPC = 3, ddsRlog, sampleNames = NULL,
#                          colourPalette = colourPalette, shapePalette = shapePalette)
# plotList <- add_to_plot_list( plotList, 
#                               pc1_pc3Plot, 
#                               file.path(rootPath, 'plots', 'Figure.1f.pdf') )
# print( pc1_pc3Plot )
# 
# # PC1 against 3
# PlotFile <- file.path(rootPath, 'plots', 'pca.PCs1-3.ps')
# postscript(file=PlotFile, paper="special", width = 8, height = 8)
# print( pc1_pc3Plot + theme( legend.position = "none" ) )
# dev.off()
# 
# # PC1 against 3, with legend
# PlotFile <- file.path(rootPath, 'plots', 'pca.PCs1-3.legend.ps')
# postscript(file=PlotFile, paper="special", width = 10, height = 8)
# print( pc1_pc3Plot )
# dev.off()

```

#### 3d plot

```{r pcaPlot3D, include=TRUE}
pca <- pcaObj$pca

# plot first 3 components
# choose plot colours
plotColours <- rep( colourPalette, each = 5 )

plot3d(pca$x[,"PC1"], pca$x[,"PC2"], pca$x[,"PC3"],  col=plotColours,
       type="s", size = 1, 
       xlab="PC1", ylab="PC2", zlab="PC3" )
op <- par3d()
par3d( windowRect = c(0,0,620,512) )
rgl.viewpoint( theta = 30, phi = 5, zoom = 0.75 )

rgl.postscript( filename = file.path(rootPath, 'plots', 'Figure.1d.eps'), 
                fmt = 'eps', drawText = TRUE 
)
rgl.postscript( filename = file.path(rootPath, 'plots', 'Figure.1d.notext.eps'), 
                fmt = 'eps', drawText = FALSE 
)
rgl.snapshot( filename = file.path(rootPath, 'plots', 'Figure.1d.png'), 
              fmt = "png")
par3d(op)
```

### PC Median Heatmaps

```{r medianHeatmap, include=TRUE}
numGenes <- 100
medianPlotList <- vector('list', length = 6)
for( PCNum in 1:6 ){
  dataForPC <- pcaObj$PCData[[PCNum]]
  # counts <- dataForPC[ seq_len(numGenes), ]
  pc_tpm <- tpmAll[ rownames(dataForPC), ]

  # Medians <- apply( counts, 2, median )
  Medians <- apply( pc_tpm, 2, median, na.rm = TRUE )
  # scale by log10
  log10Median <- log10( Medians + 1 )

  log10Median.m <- melt(log10Median)
  log10Median.m$sample <- factor( rownames( log10Median.m ),
                                         levels = rownames( log10Median.m ) )
  log10Median.m$PC <- rep( paste0('PC', PCNum), nrow(log10Median.m) )
  medianPlotList[[PCNum]] <- log10Median.m
}
medianPlotData <- do.call(rbind, medianPlotList)
medianPlotData$PC <- factor( medianPlotData$PC,
                             levels = paste0('PC', 6:1) )

medianHeatmap <- ggplot(data = medianPlotData) +
  geom_tile( aes( x = sample, y = PC, fill = value ),
             colour = "grey60" ) + 
  geom_hline( data = data.frame( y = seq(0.5,6.5,1) ), 
              aes( yintercept = y ), colour = "white" ) + 
  scale_fill_gradientn( colours = c("blue", "yellow", "red"), 
                        guide = guide_colorbar(title = "Average Expression\n(log10[TPM])") ) +
  theme_void() + 
  theme( legend.position="right",
          legend.title = element_text(colour = "black", angle = 0, debug = FALSE, size = 6),
          legend.text = element_text(colour = "black", angle = 0, debug = FALSE, size = 6),
          axis.text.y =  element_text(colour="black", angle = 0, debug = FALSE ) )

# print median plot including legend to have a copy of the legend
postscript(file = file.path(rootPath, 'plots', 'Figure.1e.eps'),
           width = 7, height = 4)
print( medianHeatmap )
dev.off()
```

### Figure S2

#### PCA Matrix Plot

```{r exprPlotFunctions}
#' clusterGenes
#' Function to cluster rows (genes) of a count matrix
#' 
#' This function takes a count matrix, runs hierarchical clustering on it and 
#'    reorders the matrix based on the result
#'    
#' @param counts A numeric matrix of counts
#'
#' @return the count matrix reordered based on the result of the clustering

clusterGenes <- function( counts ){
  distMatrix <- as.dist( 1 - abs( cor(t(counts)) ) )
  # cluster and reorder correlation matrix
  hClust <- hclust(distMatrix)
  # find optimal ordering of leaves
  optOrder <- order.optimal(distMatrix, hClust$merge)
  # new ordering
  newClust <- hClust
  newClust$merge <- optOrder$merge
  newClust$order <- optOrder$order
  # order genes by optimal ordering
  counts <- counts[ newClust$order, ]
}

#' exprHeatmap
#' function to plot an expression heatmap using ggplot2
#' 
#' This is designed to plot a heatmap of a subset of the genes contributing 
#'    to a particular principal component. It expects the list of genes contributing 
#'    to PCs returned by runPCA and the PC number. You can optionally change the 
#'    number of genes plotted and whether to cluster the subset before plotting
#'    
#' @param PCNum integer, index of the PC to plot
#' @param PCDataList list, list of genes contributing to principal components
#'    as returned by runPCA
#' @param numGenes integer, number of genes to plot (ordered by their contribution to the component)
#'    default: 100
#' @param cluster logical, whether to cluster the genes before plotting
#'    default: TRUE
#'
#' @return Heatmap A ggplot2 object
#'
exprHeatmap <- function( PCNum, PCDataList, numGenes = 100, cluster = TRUE ){
  dataForPC <- PCDataList[[PCNum]]
  counts <- log10( dataForPC[ seq_len(numGenes), ] + 1 )
  if( cluster ){
    counts <- clusterGenes( counts )
  }
  
  counts.m <- cbind(
    gene_id = factor( rownames(counts),
                      levels = rownames(counts) ),
    suppressMessages(
      melt( counts, variable.name = "sample")
    )
  )
  Heatmap <- ggplot(data = counts.m) + 
    geom_raster( aes( x = sample, y = gene_id, fill = value ) ) + 
    scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                          guide = guide_colorbar(title = "log10 counts") ) + 
    theme_void() + theme( legend.position="right",
                          legend.title = element_text(colour="black" ) )
  return(Heatmap)
}

#' profile_for_PC
#' function to plot an expression profile using ggplot2
#' 
#' This is designed to plot an expression profile of a subset of the genes contributing 
#'    most to a particular principal component. It expects the list of genes contributing
#'    to PCs returned by runPCA and the PC number. You can optionally change the 
#'    number of genes plotted
#'    
#' @param PCNum integer, index of the PC to plot
#' @param PCDataList list, list of genes contributing to principal components
#'    as returned by runPCA
#' @param tpms matrix, tpm to use to plot profile
#' @param numGenes integer, number of genes to plot (ordered by their contribution to the component)
#'    default: 100
#'
#' @return Heatmap A ggplot2 object
#'
profile_for_PC <- function( PCNum, PCDataList, tpms, numGenes = 100, size = 2 ){
  dataForPC <- PCDataList[[PCNum]]
  # print(numGenes)
  # print(dim(dataForPC))
  # print(dim(tpms))
  # get TPM for top 100 genes
  # check gene exists in tpm data
  genes <- rownames(dataForPC)[seq_len(numGenes)]
  genes_in_tpm_list <- vector('list', length = numGenes)
  genes_not_in_tpm_list <- vector('list', length = numGenes)
  for( i in seq_len(numGenes) ){
    gene <- genes[i]
    if( any(rownames(tpms) == gene) ){
      genes_in_tpm_list[[i]] <- gene
    } else {
      genes_not_in_tpm_list[[i]] <- gene
    }
  }
  genes_in_tpm <- do.call(c,genes_in_tpm_list)
  genes_not_in_tpm <- do.call(c,genes_not_in_tpm_list)
  if( length(genes_not_in_tpm) > 0 ){
    cat(sprintf('Some of the genes contributing to PC%d are not present in the TPM data. %s. Skipping ...\n', PCNum, paste(genes_not_in_tpm, sep = ", ") ) )
  }
  tpm_for_PC <- tpms[ genes_in_tpm, ]
  tpm_for_PC_scaled <- scale(t(tpm_for_PC))
  tpm_scaled_ByStageList <- split.data.frame(tpm_for_PC_scaled, rnaseqSampleInfo$condition)
  tpm_scaled_MeanByStage <- do.call(cbind, lapply(tpm_scaled_ByStageList, colMeans))
  
  mean_tpm_scaled_MeanByStage <- melt(colMeans(tpm_scaled_MeanByStage))
  mean_tpm_scaled_MeanByStage$stage <- rownames(mean_tpm_scaled_MeanByStage)
  
  tpm_scaled_MeanByStage <- melt(tpm_scaled_MeanByStage)
  
  profile_plot <- ggplot(data = tpm_scaled_MeanByStage) + 
    geom_line(aes(x = Var2, y = value, group = Var1), 
              colour = "grey70", size = size/4) + 
    geom_line(data = mean_tpm_scaled_MeanByStage, aes(x = stage, y = value, group = 1), colour = "firebrick3", size = size/2) +
    theme_minimal() + theme(axis.text.x = element_blank()) + 
    labs(x = 'Stage', y = 'TPM (Mean Centred and Scaled)')

  return(profile_plot)
}

```

```{r pcaMatrixPlot_func}
#' PCA_matrixPlot
#' Plot a matrix of plots representing all the principal components
#' 
#' Plot a matrix of plots for the principal components returned by runPCA.
#'    The plots on the diagonal are heatmaps of the top 100 genes contributing to the PC
#'    Under the diagonal are scatterplots of the components plotted against each other
#'    For example, the plot in column 1, row 2 is PC1 on the x-axis plotted against
#'    PC 2 on the y-axis
#'    
#' @param PCDataList list, list of genes contributing to principal components
#' @param pca object returned by prcomp 
#' @param ddsRlog DESeqTransform, Rlog transformed data
#' @param size number for size of points
#' @param profile_type switch for type of plot for diagonal
#'        one of 'profile' (line graph of expression profiles)
#'            or 'heatmap' (heatmap of expression profiles)
#' @param ... other parameters passed to exprHeatmap/profile_for_PC
#'
#' @return tpm A numeric matrix normalized by library size and feature length
#'
PCA_matrixPlot <- function( PCDataList, pca, ddsRlog, size = 2, 
                            profile_type = 'heatmap', tpms = tpmFilt,
                            numGenes = 100 ){
  matrixPlotList <- vector( "list", length = length(PCDataList) * length(PCDataList) )
  propVarPC <- pca$sdev^2 / sum( pca$sdev^2 )
  # loop through PCs ( ones above varPCThreshold )
  for( firstPC in seq_len( length(PCDataList) ) ){
    for( secondPC in seq_len( length(PCDataList) ) ){
      cat( sprintf('First PC:%d Second PC:%d\n', firstPC, secondPC) )
      # if firstPC == secondPC, plot expression heatmap
      # else plot firstPC against second PC
      if( firstPC == secondPC ){
        if(profile_type == 'heatmap'){
          plot <- exprHeatmap( firstPC, PCDataList, numGenes = numGenes )
          plot <- plot + theme( axis.title = element_blank(),
                                legend.position="none" )
        } else if(profile_type == 'profile'){
          plot <- profile_for_PC( firstPC, PCDataList, tpms, numGenes, size )
          plot <- plot + theme( axis.title = element_blank(),
                                legend.position="none" )
        }
      } else if( firstPC > secondPC ){
        # blank spaceholder plot
        plot <- ggplot( data = data.frame() ) + geom_blank() + theme_void()
      } else{
        plot <- PCA_plot( pca, propVarPC, firstPC, secondPC, ddsRlog,
                          colourPalette = colourPalette, 
                          shapePalette = shapePalette,
                          size = size )
        plot <- plot + 
          theme( axis.title = element_blank(),
                 axis.text = element_blank(),
                 axis.ticks = element_blank(),
                 axis.line.x = element_line(colour="black"),
                 axis.line.y = element_line(colour="black"),
                 legend.position="none" )
      }
      matrixPlotList[[ length(PCDataList)*(secondPC-1) + firstPC ]] <- plot
    }
  }
  return(matrixPlotList)
}

```

```{r pcaMatrixPlot}
pca <- pcaObj$pca
PCDataList <- pcaObj$PCData
matrixPlotList <- PCA_matrixPlot( PCDataList, pca, ddsRlog, 
                                  tpms = tpmFilt, numGenes = 100, size = 1 )

# set max tpm value for heat map colour scale
heatmap_posns <- as.logical( diag(x = 1, nrow = 6, ncol = 6) )
maxtpm <- ceiling( max( sapply( matrixPlotList[ heatmap_posns ], function(x){ max(x$data$value) } ) ) )
for( i in seq_len(length(heatmap_posns))){
  if( heatmap_posns[i] ){
    matrixPlotList[[i]] <- matrixPlotList[[i]] + 
      scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                            limits = c(0,maxtpm))

  }
}

# save as eps
matrixFile <- file.path(rootPath, 'plots', 'Fig.S2-pca_matrix.eps' )
postscript(matrixFile, width = 7, height = 7, horizontal = FALSE)
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = matrixPlotList,
               nrow = 6, ncol = 6
              )
)
dev.off()

# plot one heatmap with colour bar 
postscript(file.path(rootPath, 'plots', 'Fig.S2-heatmap1.eps' ), 
           width = 7, height = 7, horizontal = FALSE)
print( matrixPlotList[[1]] + theme( legend.position = 'right' ) )
dev.off()

# matrix plot with line profiles
matrixProfilesPlotList <- PCA_matrixPlot( PCDataList, pca, ddsRlog, profile_type = 'profile',
                                  tpms = tpmFilt, numGenes = 100, size = 1 )
# save as eps
matrixFile <- file.path(rootPath, 'plots', 'Fig.S2-pca_matrix.line-profile.eps' )
postscript(matrixFile, width = 7, height = 7, horizontal = FALSE)
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = matrixProfilesPlotList,
               nrow = 6, ncol = 6
              )
)
dev.off()

```

```{r printPCAMatrixPlot, include=TRUE}
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = matrixPlotList,
               nrow = 6, ncol = 6
              )
)
```

#### ChIP-Seq

```{r h3k4_chip_seq}
stages <- c('Dome', 'Prim-5')
for (stage in stages){
  # get genes expressed and not expressed
  for (tpm_threshold in c(0,1) ){
    detected <- sapply(tpmByGeneByStageList, function(x){ all(x[[stage]] > tpm_threshold) })
    not_detected <- sapply(tpmByGeneByStageList, function(x){ all(x[[stage]] == 0) } )
    genes_detected <- data.frame(
      gene_id = names(tpmByGeneByStageList),
      detection_status = factor( rep(NA, length(detected)),
              levels = c('DETECTED', 'NOT DETECTED') )
    )
    genes_detected$detection_status[detected] <- 'DETECTED'
    genes_detected$detection_status[not_detected] <- 'NOT DETECTED'
    
    write.table(genes_detected, 
                file.path(rootPath, 'output', paste0('genes_detected.', tpm_threshold, '-tpm.', stage, '.txt') ),
                quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")
  }
}

```

## Figure 3
### Fig3a
#### Max Stage Clusters TPM heatmap

```{r cluster_func}
#' getGenesForStage
#' Return the counts for a given stage index
#' 
#' Return the columns of a matrix using a vector of assigned indices and 
#'    the desired index. In this function the columns are genes and 
#'    the rows are samples.
#'
#' @param stageIndex integer, 
#' @param countsScaled matrix, counts matrix to subset (rows = Stage x cols = Genes)
#' @param maxMeanIndices integer, vector of indices indicating the stage for max expression
#'    same length as cols of countsScaled
#'
#' @return matrix subset using the indices
#'
getGenesForStage <- function( stageIndex, countsScaled, maxMeanIndices ){
  countsScaled[ , maxMeanIndices == stageIndex ]
}

#' clusterByGenes
#' Cluster and order a count matrix
#' 
#' Cluster the supplied count matrix by columns (Genes). The counts are first scaled 
#'    and then clustered using Pearson's correlation coefficient as a distance measure.
#'    The leaves of the reulsting tree are then reordered using the order.optimal function from the cba package.
#'    The count matrix is then reordered using this ordering and returned
#'
#' @param stageIndex integer, the index of the counts list to run clustering on
#' @param countsByStageList list, counts matrices to cluster (rows = Stage x cols = Genes)
#'
#' @return matrix reordered by clustering
#'
clusterByGenes <- function( stageIndex, countsByStageList ){
  stageCounts <- countsByStageList[[stageIndex]]
  stagename <- levels(rnaseqSampleInfo$stageName)[stageIndex]
  stagename <- gsub("%", "pc", stagename)
  # centre and scale numbers
  scaledCounts <- scale(stageCounts)
  geneCor <- cor(scaledCounts)
  distanceMatrix <- as.dist( 1-abs(geneCor) )
  # cluster and reorder correlation matrix
  hClust <- hclust(distanceMatrix)
  # find optimal ordering of leaves
  optOrder <- order.optimal(distanceMatrix, hClust$merge)
  # reorder counts matrix
  newClust <- hClust
  newClust$merge <- optOrder$merge
  newClust$order <- optOrder$order
  stageCounts <- stageCounts[ , newClust$order]

  return(stageCounts)
}
```

```{r heatmapFunction}
#' ggplotExprHeatmap
#' function to plot an expression heatmap using ggplot2
#' 
#' This is designed to plot an expression heatmap of a count matrix. 
#'    The colour scheme is a gradient from blue through yellow to red
#'    
#' @param exprMatrix matrix, count matrix to plot
#'    rows are genes, columns are samples
#' @param legendPosition character, one of 'left', 'right', 'top', 'bottom' or 'none'
#'
#' @return Heatmap ggplot2 object
#'
ggplotExprHeatmap <- function( exprMatrix, legendPosition = 'left' ){
  # reshape data for heatmap
  exprMatrix.m <- melt(exprMatrix)
  colnames(exprMatrix.m) <- c("Gene", "Sample", "Value")
  # reorder levels of gene
  exprMatrix.m$Gene <- factor( exprMatrix.m$Gene,
                               levels = rev(levels(exprMatrix.m$Gene)) )
  
  Heatmap <- ggplot(data = exprMatrix.m) + 
    geom_raster( aes( y = Gene, x = Sample, fill = Value ) ) + 
    scale_fill_gradientn( colours = c("blue", "yellow", "red") ) + 
    theme_void() + theme( legend.position=legendPosition,
                          legend.title = element_text(colour="black" ) )
  return( Heatmap )
}
```

```{r tpm_by_maxStage, include=TRUE}
# transpose and split tpms by Stage
tpmByStageList <- split(t(tpmFilt), rnaseqSampleInfo$stageName)
# turn into a matrix with five observations for each stage
tpmByStageMatList <- lapply(tpmByStageList, function(x){ matrix(x,nrow=5) } )
# do colmeans
meansByStageList <- lapply(tpmByStageMatList, colMeans)
# join back together
meansByStage <- do.call(rbind, meansByStageList)
# find max index and max
maxMeanIndices <- apply(meansByStage,2,which.max)
maxMeans <- apply(meansByStage,2,max)

# # count up genes assigned to each stage
GenesPerStage <- table(maxMeanIndices)
names(GenesPerStage) <- levels(rnaseqSampleInfo$stageName)

# get tpm data using max mean indices
tpmByStage <- lapply( seq_len(nlevels(rnaseqSampleInfo$stageName)), getGenesForStage, t(tpmFilt), maxMeanIndices )

```

```{r tpm_by_maxStage_clustered}
# cluster the genes inside each stage
tpmByStageClusteredList <- lapply( seq_len(length(tpmByStage)), clusterByGenes, tpmByStage )
# join back together and transpose
tpmByStageClustered <- do.call(cbind, tpmByStageClusteredList)
tpmByStageClustered <- t(tpmByStageClustered) # rows are now genes
```

```{r tpmMaxScaledHeatmap, include=TRUE}
# scale by max value per gene
geneMax <- apply(tpmByStageClustered, 1, max)
# scale works on columns so you need to transpose it for scaling then transpose it back again
tpmByStageClusteredMaxScaled <- t(scale( t(tpmByStageClustered), center = FALSE, scale = geneMax ))

# plot heatmap clustered
tpmMSHeatmap <- ggplotExprHeatmap( tpmByStageClusteredMaxScaled, legendPosition = 'right' )
# Change colour bar title
tpmMSHeatmap <- tpmMSHeatmap + guides( fill = guide_colorbar(title = "TPM\n(max scaled)" ) )

# do one with legend and one without
postscript(file.path(rootPath, 'plots', 'Fig.3a.tpm-heatmap.eps'),
           width = 5, height = 5 )
print(tpmMSHeatmap)
dev.off()

postscript(file.path(rootPath, 'plots', 'Fig.3a.tpm-heatmap.nolegend.ps'),
           width = 3, height = 5 )
ggplotExprHeatmap( tpmByStageClusteredMaxScaled, legendPosition = 'none' )
dev.off()

postscript( file = file.path(rootPath, 'plots', 'Fig.3a.tpm_heatmap.ps'),
           width = 3, height = 5 )
print(tpmMSHeatmap)
dev.off()

```

```{r getGeneNames}
#### Named vs Unnamed genes
AllGenesInfoFile <- file.path(rootPath, 'dataFiles', 
                              paste0('Danio_rerio.e', ensVersion, '.geneInfo.tsv' ) )

if( file.exists(AllGenesInfoFile) ){
  AllGenesInfo <- read.table(AllGenesInfoFile, sep="\t", header=TRUE)
} else{
  # connect to ensembl
  # need the correct archive site 85 = jul2016.archive.ensembl.org
  # to connect to the current database use
  # ensBiomart <- useMart( "ensembl", dataset="drerio_gene_ensembl")
  ensBiomart <- useMart(host='jul2016.archive.ensembl.org', biomart = "ENSEMBL_MART_ENSEMBL", dataset="drerio_gene_ensembl")
  
  # Biomart query to get chr, start and end for all genes
  # filter: ensembl_gene_id, values = ''
  # attributes: ensembl_gene_id, external_gene_name, chromosome_name, start_position, end_position
  AllGenesInfo <- getBM(
    filters = "",
    attributes = c('ensembl_gene_id', 'external_gene_name',
                   'chromosome_name', 'start_position', 'end_position' ),
    values = "",
    mart = ensBiomart
  )
  
  write.table(AllGenesInfo, file = AllGenesInfoFile, sep="\t", quote = FALSE, col.names = TRUE, row.names = FALSE)
}

# add gene ids as row names for subsetting
rownames(AllGenesInfo) <- AllGenesInfo$ensembl_gene_id

# make named vector of gene names for later
geneNames <- as.character( AllGenesInfo$external_gene_name )
names(geneNames) <- as.character( AllGenesInfo$ensembl_gene_id )

# set any empty gene names to the corresponding gene id
for( i in seq_len(length(geneNames)) ){
  if( geneNames[i] == "" ){
    geneNames[i] <- names(geneNames)[i]
  }
}
```

```{r unchar_genes}
# a set of patterns to check for
patterns <- c(
  '^[A-Z][A-Z][0-9]{6}\\.[0-9]+$',
  '^CABZ[0-9]{8}\\.[0-9]+$',
  '^im:[0-9]{7}$',
  '^si:.*$',
  '^wu:.*$',
  '^zgc:[0-9]{5,6}$'
)
# produce a list of which genes match which patterns
logicalList <- lapply( as.list(patterns),
                       function( pattern, AllGenesInfo ){ grepl(pattern, AllGenesInfo$external_gene_name, perl = TRUE ) },
                       AllGenesInfo )
# OR lists together
uncharacterisedGenesL <- Reduce('|', logicalList)

uncharacterisedGeneIds <- AllGenesInfo$ensembl_gene_id[ uncharacterisedGenesL ]
characterisedGeneIds <- AllGenesInfo$ensembl_gene_id[ !uncharacterisedGenesL ]

# this produces a list of lists.
# each element in the list is a list of length 2 with
# 1. The ids of the characterised genes assigned to this stage
# 2. The ids of the UNcharacterised genes assigned to this stage
genesInClustersList <-lapply( tpmByStageClusteredList,
        function( tpmSubset, uncharacterisedGeneIds, characterisedGeneIds ){
          # this goes through each gene in the cluster and checks whether it exists in the uncharacterised set. This produces a list of logical vectors which are ORed together and used to subset the uncharacterised genes vector
          tpmSubsetGenes <- colnames(tpmSubset)
          unknown <-  Reduce("|",
                             lapply( uncharacterisedGeneIds,
                                     function( x, tpmSubsetGenes ){
                                       tpmSubsetGenes == x },
                                     tpmSubsetGenes )
          )
          # this does the same for the characterised genes vector
          known <- Reduce("|",
                          lapply( characterisedGeneIds,
                                  function( x, tpmSubsetGenes ){
                                    tpmSubsetGenes == x },
                                  tpmSubsetGenes )
          )
          # the vectors are returned in a list
              return(
              list( 'Characterised Genes' = tpmSubsetGenes[ known ],
                    'Uncharacterised Genes' = tpmSubsetGenes[ unknown ] )
            )
        },
        uncharacterisedGeneIds,
        characterisedGeneIds
)

# check numbers make sense
totalGenesInCluster <- sapply(tpmByStageClusteredList, ncol)
geneCountsByCategory <- sapply(genesInClustersList, function(x){ sapply(x, length) } )
countTotals <- apply(geneCountsByCategory, 2, sum)
if( !all( totalGenesInCluster == countTotals ) ){
  stop('Something went wrong counting characterised and uncharacterised genes')
}
geneCountsByCategory <- t(geneCountsByCategory)
rownames(geneCountsByCategory) <- levels(rnaseqSampleInfo$stageName)

geneCountTable <- data.frame(
  row.names = levels(rnaseqSampleInfo$stageName),
  "Named Genes" = geneCountsByCategory[,1],
  "Unnamed Genes" = geneCountsByCategory[,2],
  "Percentage" = round( (geneCountsByCategory[,2]/(geneCountsByCategory[,1] + geneCountsByCategory[,2]))*100, digits = 1 )
)

geneCountsFile <- file.path(rootPath, 'output', paste0('e', ensVersion, '.maxStageClusters.gene_counts.tsv') )
write.table(geneCountTable, file = geneCountsFile, sep = "\t", quote = FALSE,
            row.names = TRUE, col.names = NA )

# plot counts table as tile plot
geneCountsByCategory.m <- melt(geneCountsByCategory)
geneCountsByCategory.m$value <- as.character( geneCountsByCategory.m$value )

geneCountsByCategory.m.List <- split( geneCountsByCategory.m, geneCountsByCategory.m$Var2 )
  data <- geneCountsByCategory
  rows <- nrow(data)

  x <- rep( c(2, 0.5), rows )
  j <- 2 * rows
  width <- rep( c(2,1), rows )
  height <- numeric( length = j )
  y <- numeric(length = j)
  labels <- character(length = j)
  # go through stages backwards. from 0 on the plot
  height_offset <- 0
  for( stage in rev(rownames(geneCountsByCategory)) ){
    cat(stage, "\n")
    total_genes <- sum(geneCountsByCategory[stage, ])
    height[c(j,j-1)] <- total_genes
    labels[j] <- as.character(geneCountsByCategory[stage, 'Characterised Genes'])
    pc_un <- sprintf('%.1f%%', geneCountsByCategory[stage, 'Uncharacterised Genes']/total_genes*100)
    labels[j-1] <- paste0(geneCountsByCategory[stage, 'Uncharacterised Genes'], ' (',
                          pc_un, ')')
    y[c(j,j-1)] <- total_genes/2 + height_offset
    height_offset <- height_offset + total_genes
    j <- j - 2
  }
tableTilePlotData <- data.frame( x = x, y = y, 
                                 width = width, height = height, labels = labels )

tablePlot <- ggplot( data = tableTilePlotData ) + 
  geom_tile( aes( x = x, y = y, width = width, height = height), fill="grey90", colour = "white" ) +
  geom_text( aes( x = x, y = y, label = labels ), size = 2.1 ) + 
  theme_void()

postscript( file = file.path(rootPath, 'plots', 'plotTable.eps'), 
            width = 1.1, height = 5.5, paper="special",
            horizontal = FALSE)
print(tablePlot)
dev.off()

```

#### ZFA enrichment

```{r loadZFAData}
ZFADataFile <- file.path(rootPath, 'dataFiles', 'zfa.all.sig.tsv')
ZFAData <- read.table(ZFADataFile, header=TRUE, sep="\t")

# set levels of stage factor
ZFAData$Stage <- factor( ZFAData$Stage,
                         levels(rnaseqSampleInfo$stageName) )

# set levels of Germlayer
ZFAData$Germlayer <- factor( as.character(ZFAData$Germlayer),
                             levels = c("ectoderm", "mesoderm", "endoderm",
                                        "yolk-derived", "NULL") 
                            )

# set levels of Tissue
ZFAData$Tissue <- factor( as.character( ZFAData$Tissue ),
                          levels = c("ectoderm cell", "epidermis", "neural", "neural crest",
                            "hypoblast", "organizer", "hatching gland", 
                            "muscle", "notochord", "mesenchyme", 
                            "skeleton", "cartilage", 
                            "haematopoietic system", "kidney", "spleen",
                            "reproductive system", "fin",
                            "endoderm cell", "endocrine system", "gut",
                            "liver", "yolk", "YSL", "yolk ball/extension", "NULL"
                            )
)

# calculate log2FC enrichment
ZFAData$log2FCEnriched <- log2( ZFAData$Significant/ZFAData$Expected )

```

```{r heatmap_pvalue_germlayer}
# make matrix of pvalues
ZFAData.germlayer.p <- ddply(ZFAData, .(Stage, Germlayer), 
                             summarise, minP = min(p.adjusted) )
ZFAData.germlayer.p.c <- acast( ZFAData.germlayer.p, 
                                Germlayer ~ Stage, 
                                value.var = "minP", fill = 1) # 1 becomes 0 when logged
# log 10
ZFAData.germlayer.p.c <- log10(ZFAData.germlayer.p.c)
# remove NULL row
ZFAData.germlayer.p.c <- ZFAData.germlayer.p.c[ !grepl("NULL", rownames(ZFAData.germlayer.p.c) ), ]

```

```{r heatmap_pvalue_tissue}
# make matrix of pvalues
ZFAData.tissue.p <- ddply(ZFAData, .(Stage, Tissue), 
                             summarise, minP = min(p.adjusted) )
ZFAData.tissue.p.c <- acast( ZFAData.tissue.p, 
                                Tissue ~ Stage, 
                                value.var = "minP", fill = 1)# 1 becomes 0 when logged
# log 10
ZFAData.tissue.p.c <- log10(ZFAData.tissue.p.c)
# remove NULL row
ZFAData.tissue.p.c <- ZFAData.tissue.p.c[ !grepl("NULL", rownames(ZFAData.tissue.p.c) ), ]

```

```{r exprHeatmapMatched, include=TRUE}
ZFAData.germlayer.p.m <- melt( ZFAData.germlayer.p.c )
colnames(ZFAData.germlayer.p.m) <- c('Category', 'Stage', 'log10pvalue')

ZFAData.tissue.p.m <- melt(ZFAData.tissue.p.c)
colnames(ZFAData.tissue.p.m) <- c('Category', 'Stage', 'log10pvalue')

ZFAData.category.p.m <- rbind( ZFAData.germlayer.p.m, ZFAData.tissue.p.m)
ZFAData.category.p.m.List <- split(ZFAData.category.p.m, ZFAData.category.p.m$Category)
createTilePlotData <- function( index, ZFAData.category.p.m.List ){
  data <- ZFAData.category.p.m.List[[index]]
  rows <- nrow(data)
  x <- rep( index - 0.5, rows )
  width <- rep( 1, rows )
  height <- numeric( length = rows )
  j <- rows
  # go through stages backwards. from 0 on the plot
  offset <- 0
  y <- vector(length = rows)
  for( stage in levels( ZFAData.category.p.m.List[[index]]$Stage )[ order( seq_len(rows), decreasing = TRUE ) ] ){
    # height[j] <- countTotals[ levels(rnaseqSampleInfo$stageName) == stage ][1]
    height[j] <- ncol( tpmByStage[[ which(levels(rnaseqSampleInfo$stageName) == stage) ]] )
    y[j] <- height[j]/2 + offset
    offset <- offset + height[j]
    j <- j - 1
  }
  cbind( data, x, y, width, height )
}

tilePlotDataList <- lapply( seq_len(length(ZFAData.category.p.m.List)),
        createTilePlotData,
        ZFAData.category.p.m.List
)
tilePlotData <- do.call( rbind, tilePlotDataList )

pvalueCombinedHeatmap <- ggplot( data = tilePlotData ) + 
  geom_tile( aes( x = Category, y = y, height = height, fill = log10pvalue ),
             colour = "grey70" ) + 
  scale_fill_gradientn( colours = c("red", "orange", "yellow", "white"),
                        guide = guide_colorbar(title = "log10 p-value") ) + 
  theme_void() + theme( legend.title = element_text(colour="black") )

# add to plot list
pdf( file.path(rootPath, 'plots', 'Figure.3-1.zfa-heatmap.pdf') )
print(pvalueCombinedHeatmap)
dev.off()
```

```{r goEnrichment, eval=FALSE}
# do Go enrichment on genes assigned to each stage by max mean expression

# # function to return sig genes by 'pvalue'
# sigLevel <- 0.05
# topDiffGenes <- function(allScore) {
#   return(allScore < sigLevel)
# }

code2ontology <- list(
  "BP" = 'biological_process',
  "CC" = 'cellular_component',
  "MF" = 'molecular_function'
)
# Read in GO annotation
# see GO-biolayout.md for how these map files are produced
id2GOList <- list()
for( ontology in c('BP', 'CC', 'MF') ){
  mapFile <- file.path( 
    rootPath,
    'dataFiles',
    'topgo',
    paste0(code2ontology[[ontology]], '.e', ensVersion, '.map' )
  )
  id2GOList[[ontology]] <- readMappings(file = mapFile)
}

#' runTopGO
#' function to run GO enrichment using topGO
#' 
#' Takes the counts list split by stage and a stage index and runs GO enrichment
#'    using topGO on the gene set in the counts matrix.
#'    Outputs a file of results of the pvalue associated with each GO Term and
#'    pdfs showing the position of the most significant terms within the GO graph
#'    
#' @param stageIndex integer, index of the gene set to use
#' @param countsList list, list of count matrices split by stage
#' @param ontologyClass character, one of 'BP', 'MF' or 'CC'
#' @param allGenes character, named vector of the complete set of genes to compare to
#'
#' @return
#'
# runTopGO <- function( stageIndex, countsList, ontologyClass, allGenes, sigLevel = 0.05 ){
runTopGO <- function( gene_list, ontologyClass, allGenes, outputPrefix = 'topGO', sigLevel = 0.05 ){
  # construct a factor for the sig genes
  sigGenes <- rep(0, length(allGenes))
  names(sigGenes) <- allGenes
  sigGenes[ gene_list ] <- 1
  sigGenes <- factor(sigGenes)
  
  # Make topGOdata object
  # nodeSize=10 : prune GO hierarchy of terms associated with < 10 genes
  GOdata <- new("topGOdata", ontology=ontologyClass, allGenes=sigGenes,
                    annot=annFUN.gene2GO, 
                    gene2GO=id2GOList[[ontologyClass]], nodeSize=10)
  # Run topGO
  # result <- runTest(GOdata, algorithm="elim", statistic="ks")
  result <- runTest(GOdata, algorithm="weight01", statistic="fisher")
  nodecount <- length(score(result))
  allRes <- GenTable(GOdata, pvalue=result, topNodes=nodecount)
  # Horrible way to get all the genes associated with each term
  allRes$Genes <- sapply(allRes$GO.ID,
                         function(x) gsub('[c()" \n]', '', genesInTerm(GOdata, x)))
  allRes$pvalue[ allRes$pvalue == '< 1e-30' ] <- 1e-30
  
  sigRes <- allRes[suppressWarnings(as.numeric(allRes$pvalue)) < sigLevel,]
  
  write.table( allRes, file=paste0(outputPrefix, ".tsv"), quote=FALSE,
               row.names=FALSE, sep="\t" )
  
  # Write PDF
  pdf(paste0(outputPrefix, ".pdf"))
  try(suppressWarnings(showSigOfNodes(GOdata, score(result),
                                      firstSigNodes=5, useInfo="all")), silent=TRUE)
  try(suppressWarnings(showSigOfNodes(GOdata, score(result),
                                      firstSigNodes=10, useInfo="all")), silent=TRUE)
  try(suppressWarnings(showSigOfNodes(GOdata, score(result),
                                      firstSigNodes=nrow(sigRes), useInfo="all")), silent=TRUE)
  try(suppressWarnings(lapply(sigRes[,1],
                              function(x) showGroupDensity(GOdata, x))), silent=TRUE)
  dev.off()
  
  return(sigRes)
}
```

```{r run_GO, include=TRUE}
allGenes <- do.call(c, lapply(tpmByStage, function(x){ colnames(x) } ) )
for( ontologyClass in c('BP', 'MF', 'CC') ){
  lapply(seq_len(length(tpmByStage)), 
         function(stageIndex, tpmByStage, ontologyClass, allGenes, sigLevel){
           stageSubset <- tpmByStage[[stageIndex]]
           stageName <- levels(rnaseqSampleInfo$stageName)[stageIndex]
           stageName <- gsub("%", "pc", stageName)
           outputPrefix <- file.path( 
             'output',
             'topgo',
             'maxByStage',
             paste(stageName, ontologyClass, 'topGO', sep='.')
           )
           gene_list <- colnames(stageSubset)
           runTopGO( gene_list, ontologyClass, allGenes, outputPrefix , sigLevel )
         },
         tpmByStage, ontologyClass, allGenes, 0.05
       )
}

#' outputStageGenes
#' outputs of file of gene Ids with gene names for each stage
#' 
#' Joins the gene ids for the genes assigned to a stage to gene names and
#'    outputs a file of gene name, gene Id pairs
#'    
#' @param stageIndex integer, index of the gene set to use
#' @param countsList list, list of count matrices split by stage
#' @param allGenes character, named vector of the complete set of genes to compare to
#'
#' @return 
#'
outputStageGenes <- function( stageIndex, countsList, allGenes ){
  stageSubset <- countsList[[stageIndex]]
  stageName <- levels(rnaseqSampleInfo$stageName)[stageIndex]
  stageName <- gsub("%", "pc", stageName)
  
  # output significant genes
  sigGenes <- rep(0.95, length(allGenes))
  names(sigGenes) <- allGenes
  sigGenes[ colnames(stageSubset) ] <- 0.01
  sigGenesSorted <- sigGenes[ order( names(sigGenes) ) ]
  genes <- data.frame(
    gene_id = names(sigGenesSorted)[ sigGenesSorted < 0.05 ]
  )
  geneInfo <- merge(
    mcols(dds)[ , c(geneIdColumnName, "Gene.name")],
    genes, by.x = c(1), by.y = c(1)
  )
  geneInfo <- geneInfo[ , c(2,1) ]
  
  outputPrefix <- file.path(
    rootPath,
    'output',
    'topgo',
    'maxByStage',
    stageName
  )
  write.table(geneInfo, file=paste0(outputPrefix, ".gene-list.tsv"),
              quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
  
}

invisible( lapply(seq_len(length(tpmByStage)), outputStageGenes, tpmByStage, allGenes ) )
```

```{bash parse_GO, eval=FALSE}
# Run parse_GO script on max stage GO output
# add local library paths
eval $(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)
adjustedP=$(echo "0.05/18" | bc -l | sed -e 's|^|0|')

# for stage in '1-cell' '2-cell' '128-cell' '1k-cell' 'Dome' '50pc-epiboly' 'Shield' '75pc-epiboly' '1-4-somites' '14-19-somites' '20-25-somites' 'Prim-5' 'Prim-15' 'Prim-25' 'Long-pec' 'Protruding-mouth' 'Day-4' 'Day-5'

for ontology in BP CC MF
do
for stage in $( cut -f6 dataFiles/rnaseq/zfs-rnaseq-sampleInfo.tsv | uniq | grep -v stageName | sed -e 's|%|pc|' )
do
perl ./parse_GO_results.pl \
--enriched --sig_level $adjustedP \
--fold_enrichment 1.3 --min_genes 5 \
--output_file output/topgo/maxByStage/$stage.$ontology.topGO.sig.tsv \
output/topgo/maxByStage/$stage.$ontology.topGO.tsv \
output/topgo/maxByStage/$stage.gene-list.tsv > output/topgo/maxByStage/$stage.$ontology.enriched-GO.tsv
done
done

# concatenate results
perl -le 'print join("\t", qw{Stage GO.ID Term Domain Expected Observed pvalue FoldEnrichment});' \
 > output/topgo/maxByStage/topGOResults.sig.tsv
for stage in $( cut -f6 dataFiles/rnaseq/zfs-rnaseq-sampleInfo.tsv | \
uniq | grep -v stageName | sed -e 's|%|pc|')
do
for ontology in BP CC MF
do
perl -F"\t" -lane 'BEGIN{
  %domain_for = (
    BP => "biological_process",
    MF => "molecular_function",
    CC => "cellular_component",
  );
}
{$domain = $domain_for{"'$ontology'"};
print join("\t", "'$stage'", @F[0,1], $domain, @F[3,4,2,5]);
}' \
output/topgo/maxByStage/$stage.$ontology.enriched-GO.tsv 
done
done >> output/topgo/maxByStage/topGOResults.sig.tsv

```

### Undetected genes

```{r undetected_GO}
# genes that are not above threshold
undetectedGenes <- names(genesAboveThreshold)[ !genesAboveThreshold ]
# # or genes that are all zeros
# undetectedGenes <- rownames(tpm)[ rowSums(tpm) == 0 ]

for( ontologyClass in c('BP', 'MF', 'CC') ){
  outputPrefix <- file.path( 
             'output',
             'topgo',
             'maxByStage',
             paste('undetected', ontologyClass, 'topGO', sep='.')
           )
  sigRes <- runTopGO( undetectedGenes, ontologyClass, allGenes, outputPrefix , sigLevel )
}

```

### GO Enrichment on biolayout clusters

```{r loadcluster_data}
# read in cluster data
clusterFile <- file.path(rootPath, 'dataFiles', 'zfs-grcz10.tpm_r-0.94_pearson.cluster.info.txt')
cluster_data <- read.table(clusterFile, sep="\t", header=TRUE)
rownames(cluster_data) <- as.character( cluster_data$gene_id )
# get cluster info
# split cluster_data by cluster
clusters <- split(cluster_data, cluster_data$cluster)
```

```{r unnamed_in_clusters}
# which clusters have the most unnamed genes
biolayout_named <- sapply(clusters,
       function(cluster){
         genes <- as.character(cluster$name)
         unnamedL <- 
           Reduce('|', lapply(patterns,
                            function(pattern, genes){
                              grepl(pattern, genes, perl = TRUE)
                            },
                            genes
          ))
         return( c( sum(!unnamedL), sum(unnamedL) ) )
       }
)

# fraction_unnamed <- biolayout_named[2, ] / apply(biolayout_named, 2, sum)
# fraction_unnamed[ order(fraction_unnamed, decreasing = TRUE)]
```

```{r cluster_exp_profiles, include=TRUE}
meanTpmByStage <- 
  t( do.call('rbind',
              lapply(tpmFiltByStageList, colMeans) ) )

# for each cluster, get mean Tpm for genes, scaled and center and plot
cluster_profile_data_list <- vector('list', length = length(clusters))
for( cluster_num in seq_len(length(clusters))){
  meanTpm_for_cluster <- meanTpmByStage[as.character(clusters[[cluster_num]]$gene_id), ]
  profile_data <- data.frame(
    stage = factor( colnames(meanTpm_for_cluster),
                    levels = colnames(meanTpm_for_cluster) ),
    cluster_name = rep(sprintf('Cluster%03d', cluster_num), ncol(meanTpm_for_cluster)),
    tpm_centred_scaled = colMeans(t(scale(t(meanTpm_for_cluster)))),
    mean_tpm = colMeans(meanTpm_for_cluster),
    log10_mean_tpm = log10( colMeans(meanTpm_for_cluster) )
  )
  cluster_profile_data_list[[cluster_num]] <- profile_data
}

min_value <- min(sapply(cluster_profile_data_list, function(x){min(x$tpm_centred_scaled)}))
max_value <- max(sapply(cluster_profile_data_list, function(x){max(x$tpm_centred_scaled)}))

# create a cluster plot for each cluster
for( cluster_num in seq_len(length(clusters))){
  cluster_profile_file <- file.path(rootPath, 'output', 'biolayout-clusters-files', 
                                    sprintf('Cluster%03d.png', cluster_num) )
  png(cluster_profile_file, width = 144, height = 144)
  print(ggplot(data = cluster_profile_data_list[[cluster_num]], 
               aes(x = stage, y = tpm_centred_scaled, group = 1) ) + 
    geom_path(size = 1.5, colour = 'firebrick3') +
    ylim( c(min_value, max_value) ) +
    theme_minimal() +
    theme( axis.text.x = element_blank(),
           axis.title = element_blank() ) )
  dev.off()
}

# # plot with sample strip
# profile_plot <- 
#   ggplot(data = cluster_profile_data_list[[cluster_num]], 
#           aes(x = stage, y = tpm_centred_scaled, group = 1) ) + 
#     geom_path(size = 1.5, colour = 'firebrick3') +
#     ylim( c(min_value, max_value) ) +
#     theme_minimal() +
#     theme( axis.text.x = element_blank(),
#            axis.title = element_blank() )
# 
# grid.newpage()
# grid.draw( 
#   arrangeGrob( grobs = list( profile_plot,
#                              sampleStrip + theme( plot.margin = unit(c(0,0.01,0,0.05), 
#                                                                      units = "npc") ) ), 
#                nrow = 2,
#                heights=c(0.9,0.1)
#               )
# )


# plot clusters 
cluster_numbers <- c(2,3,5,26,27,30,36,49)
combined_profile_data <- do.call(rbind, 
                                 lapply(cluster_numbers,
                                        function(x){
                                          cluster_profile_data_list[[x]] }
                                 )
)

# colour palette
colour_blind_palette <- 
  c( 'blue' = rgb(0,0.45,0.7),
     'yellow' = rgb(0.95, 0.9, 0.25),
     'sky_blue' = rgb(0.35, 0.7, 0.9),
     'purple' = rgb(0.8, 0.6, 0.7),
     'orange' = rgb(0.9, 0.6, 0),
     'vermillion' = rgb(0.8, 0.4, 0),
     'blue_green' = rgb(0, 0.6, 0.5),
     'black' = rgb(0, 0, 0) )
cb_palette <- colour_blind_palette
names(cb_palette) <- NULL

# plot 
example_clusters_scaled_profiles_plot <- 
  ggplot(data = combined_profile_data, 
          aes(x = stage, y = tpm_centred_scaled, group = cluster_name,
                 colour = cluster_name) ) + 
    geom_path( size = 0.5 ) +
    scale_color_manual(values = cb_palette,
                       guide = guide_legend(title = 'Cluster')) + 
    labs(x = 'Stage', y = 'mean TPM (Variance Scaled and Centred)') + 
    theme_minimal() +
    theme( axis.text.x = element_blank(),
           axis.text.y = element_text(size = 6),
           axis.title = element_text(size = 8),
           legend.text = element_text(size = 6),
           legend.title = element_text(size = 8)
           )

postscript(file = file.path(rootPath, 'plots', 'Fig.3c.eps'),
           width = 4, height = 2.5, paper = 'special', horizontal = FALSE)
print(example_clusters_scaled_profiles_plot)
dev.off()

# # plot as mean instead of centred and scaled
# example_clusters_mean_profiles_plot <- 
#   ggplot(data = combined_profile_data, 
#           aes(x = stage, y = mean_tpm, group = cluster_name,
#                  colour = cluster_name) ) + 
#     geom_path( size = 0.5 ) +
#     scale_color_manual(values = cb_palette,
#                        guide = guide_legend(title = 'Cluster')) + 
#     labs(x = 'Stage', y = 'mean TPM') + 
#     theme_minimal() +
#     theme( axis.text.x = element_blank(),
#            axis.text.y = element_text(size = 6),
#            axis.title = element_text(size = 8),
#            legend.text = element_text(size = 6),
#            legend.title = element_text(size = 8) )

```

```{r load_biolayout_zfa_data}
zfa_file <- file.path(rootPath, 'output', 'zfa', '0.94-e85', 'zfa.e85.sig.tsv')
biolayout_zfa_data <- read.table(zfa_file, sep = "\t", header=TRUE, quote = "\"")
```

### Figure 3-1

#### Orthologues of Named/Unnamed genes

##### Named Genes
```{r plot_orthologue_counts, include=TRUE}
# load data
orthologueCountFile <- file.path(rootPath, 'dataFiles', 'orthologue_counts.tsv')
orthologueCounts <- read.table(orthologueCountFile, header=FALSE,
                               sep="\t", col.names = c("geneId", "orthologueId", "species",
                                                       "lastCommonAncestor", "stage", "geneName",
                                                       "Named"))
#' countOrthology
#' Determine the largest taxonomic group for each gene with orthologues
#' 
#' Takes a data.frame for a gene id containing all the orthologues for
#'    that gene from Ensembl and determines the oldest last common ancestor
#'    out of 'Vertebrates', 'Teleosts' and 'Danio'
#'    
#' @param geneSubset data.frame, with columns 
#'    "geneId"
#'    "orthologueId"
#'    "species"
#'    "lastCommonAncestor"
#'    "stage"
#'    "geneName"
#'    "Named"
#'
#' @return data.frame, containing columns 'geneId', 'stage', 'Phylum', 'Named'
#'
countOrthology <- function( geneSubset ){
  # LCA <- ''
  Phylum <- ''
  if( sum(geneSubset$lastCommonAncestor == 'Euteleostomi') > 0 |
      sum(geneSubset$lastCommonAncestor == 'Vertebrata') > 0 |
      sum(geneSubset$lastCommonAncestor == 'Chordata') > 0 |
      sum(geneSubset$lastCommonAncestor == 'Bilateria') > 0 ){
    # LCA <- 'Euteleostomi'
    Phylum <- 'Vertebrates'
  } else if( sum(geneSubset$lastCommonAncestor == 'Neopterygii') > 0 |
             sum(geneSubset$lastCommonAncestor == 'Clupeocephala') > 0 |
             sum(geneSubset$lastCommonAncestor == 'Otophysi') > 0 ){
    # LCA <- 'Neopterygii'
    Phylum <- 'Teleosts'
  } else if( sum(geneSubset$lastCommonAncestor == 'Danio') > 0 ){
    # LCA <- 'Danio'
    Phylum <- 'Danio'
  }
  
  return(
    data.frame(
      geneId = geneSubset$geneId[1],
      stage = factor( geneSubset$stage[1],
                      levels = levels(rnaseqSampleInfo$stageName) ),
      # lastCommonAncestor = factor( LCA,
      #                               levels = c("Euteleostomi", "Neopterygii", "Clupeocephala", "Otophysi", "Danio" ) ),
      Phylum = factor( Phylum, levels = c("Vertebrates", "Teleosts", "Danio") ),
      Named = factor( geneSubset$Named[1],
                      levels = c("Named", "Unnamed") )
    )
  )
}

orthologueCount <- do.call("rbind",
  lapply( split(orthologueCounts, orthologueCounts$geneId),
        countOrthology
  )
)

countsByStageByPhylumByNamed <- ddply( orthologueCount, .(stage, Phylum, Named), summarise, count = length(Phylum) )
countsSplitByStageByNamed <- split(countsByStageByPhylumByNamed, list(countsByStageByPhylumByNamed$stage, countsByStageByPhylumByNamed$Named))
pcCountsByStageByNamed <- do.call("rbind",
                                  lapply(countsSplitByStageByNamed,
                                      function(x){ x$pcGenes <- x$count/sum(x$count)
                                      return(x)
                                        })
)
NamedStackedPC <- ggplot( data = pcCountsByStageByNamed[ pcCountsByStageByNamed$Named == "Named", ] ) + 
  geom_bar( aes( x = stage, y = pcGenes, fill = Phylum ), stat = "identity" ) + 
  scale_y_continuous(labels = scales::percent) + 
  guides(fill = guide_legend(reverse = TRUE)) +
  labs( x = "Stage", y = "% of Genes") +
  theme( axis.text.x = element_text(angle = 45, hjust = 1) )

# add positions to data frame to plot percentages on bars
unnamedSubset <- pcCountsByStageByNamed[ pcCountsByStageByNamed$Named == "Unnamed", ]
unnamedSubset$label_y <- integer( length = nrow(unnamedSubset) )
unnamedSubset$label_y[ unnamedSubset$Phylum == "Vertebrates" ] <- 0.1
unnamedSubset$label_y[ unnamedSubset$Phylum == "Teleosts" ] <- 0.5
unnamedSubset$label_y[ unnamedSubset$Phylum == "Danio" ] <- 0.95
unnamedSubset$label = as.character( round( unnamedSubset$pcGenes * 100, digits = 1 ) )

UnnamedStackedPC <- ggplot( data = unnamedSubset ) + 
  geom_bar( aes( x = stage, y = pcGenes, fill = Phylum ), stat = "identity" ) + 
  geom_text( aes( x = stage, y = label_y, label = label ), size = 2 ) +
  scale_y_continuous(labels = scales::percent) + 
  guides(fill = guide_legend(reverse = TRUE)) +
  labs( x = "Stage", y = "% of Genes") +
  theme( axis.text.x = element_text(angle = 45, hjust = 1 ) )

# add to plot list
plotList <- add_to_plot_list( plotList, 
                              NamedStackedPC, 
                              file.path(rootPath, 'plots', 'Figure3-1-a.pdf') )
plotList <- add_to_plot_list( plotList, 
                              UnnamedStackedPC, 
                              file.path(rootPath, 'plots', 'Figure3-1-b.pdf') )

print(NamedStackedPC)
```

##### Unnamed Genes

```{r plot_orthologue_counts_unnamed, include=TRUE}
print(UnnamedStackedPC)
```

### Figure 3-2

#### Effect of Normalisation on cluster 11

```{r normalisation_check, include=TRUE, eval=FALSE}
dataFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'spikes-counts.txt')
spikesData <- read.table(dataFile, sep="\t", header=TRUE, quote = "\"",
                         row.names = 1 )

# relabel colnames with sample names
colnames(spikesData) <- rownames(rnaseqSampleInfo)

# make DESeq object and estimate size factors
spikesDESeqDataSet <- DESeqDataSetFromMatrix(spikesData, rnaseqSampleInfo, design = ~ condition)
spikesDESeqDataSet <- estimateSizeFactors(spikesDESeqDataSet)

# replace size factors in dds with the spike-derived ones
ddsSpikeNormalised <- dds
sizeFactors(ddsSpikeNormalised) <- sizeFactors(spikesDESeqDataSet)

cluster11tpm <- tpm[ rownames( cluster_data[ cluster_data$cluster == "Cluster011", ] ), ]
# center and scale. scale works on columns. 
# need to transpose, scale then transpose back to scale rows (genes).
cluster11tpmScaled <- t( scale( t(cluster11tpm) ) )
cluster11tpmMeanByStage <- data.frame(
  Sample = factor( colnames(cluster11tpm),
                   levels = rnaseqSampleInfo$sampleName),
  Measure = rep("TPM", ncol(cluster11tpm)),
  Mean = colMeans(cluster11tpmScaled)
)

cluster11NormCounts <- counts(dds, normalized = TRUE )[ rownames( cluster_data[ cluster_data$cluster == "Cluster011", ] ), ]
# center and scale. scale works on columns. 
cluster11NormCountsScaled <- t( scale( t(cluster11NormCounts) ) )
cluster11NormCountsMeanByStage <- data.frame(
  Sample = factor( colnames(cluster11NormCounts),
                   levels = rnaseqSampleInfo$sampleName),
  Measure = rep("Library Size", ncol(cluster11NormCounts)),
  Mean = colMeans(cluster11NormCountsScaled)
)

cluster11SpikeNormCounts <- counts(ddsSpikeNormalised, normalized = TRUE )[ rownames( cluster_data[ cluster_data$cluster == "Cluster011", ] ), ]
# center and scale. scale works on columns. 
cluster11SpikeNormCountsScaled <- t( scale( t(cluster11SpikeNormCounts) ) )
cluster11SpikeNormCountsMeanByStage <- data.frame(
  Sample = factor( colnames(cluster11SpikeNormCounts),
                   levels = rnaseqSampleInfo$sampleName),
  Measure = rep("ERCC spikes", ncol(cluster11SpikeNormCounts)),
  Mean = colMeans(cluster11SpikeNormCountsScaled)
)

normalisationData <- rbind( cluster11tpmMeanByStage, 
                            # cluster11CountsMeanByStage,
                            cluster11NormCountsMeanByStage, 
                            cluster11SpikeNormCountsMeanByStage )
normalisationData$Measure <- factor(normalisationData$Measure,
                                    levels = c("TPM", "ERCC spikes", "Library Size") )

cluster11Linegraph <- ggplot( data = normalisationData ) + 
  geom_line( aes( x = Sample, y = Mean, colour = Measure, group = Measure ), 
             size = 1 ) + 
  scale_colour_manual(values=c("steelblue3", "firebrick3", "#D3C04A")) +
  theme_minimal() + theme( axis.text.x = element_text(angle=90, hjust=1, size=rel(0.5)),
                           legend.position = "top" ) +
  labs(y='Mean (Centred and Variance Scaled)' )

pdf(file.path(rootPath, 'plots', 'Figure.3-2.pdf'))
print(cluster11Linegraph)
dev.off()

print(cluster11Linegraph)
```

## Figure 4

```{r binomTest}
#' binomTest
#' Function to run binomial test
#' 
#' Performs a binomial test given the observed frequency, group size, 
#'    probability of chosen from the category at random and a category name
#'    
#' @param freq integer, the observed number within the cluster
#' @param clusterSize integer, the cluster size
#' @param prob numeric, the probability of drawing an item from the 
#'    tested category at random from the total set
#' @param clusterName character, name of the cluster from which the observed counts come
#' @param category character, name of the category of items being tested (e.g. Chr4)
#'
#' @return data.frame, containing columns 'Cluster', 'Category', 'Count', 'Expected', 'p.value'
#'
binomTest <- function( freq, clusterSize, prob, clusterName, category ){
  testRes <- binom.test(freq, clusterSize, p = prob, alternative = "greater")
  data.frame(
    Cluster = clusterName,
    Category = category,
    Count = freq,
    Expected = prob * clusterSize,
    p.value = testRes$p.value
  )
}
```

```{r chr_enrichment}
geneCounts <- table( AllGenesInfo[,"chromosome_name"] )
# subset to numerical chrs only
geneCounts <- geneCounts[ grepl("^[0-9]+$", names(geneCounts)) ]
totalGenes <- sum(geneCounts)
probs <- geneCounts/totalGenes

# This goes through each cluster for each numeric chromosome
# The chromosome is skipped if there are less than 5 genes from that chromosome in the cluster
# Else we do a binomial test using the number of genes from that chromosome in the cluster
# the prob variable is the probability of picking a gene from that chromosome 
# assuming that you are picking genes at random.
# the test is to detect clusters where there are more genes from a chromosome than would expected by chance
ChrTestRes <- vector( "list", length = length(clusters)*25 )
i <- 1
for( clusterNum in seq_len(length(clusters)) ){
  clusterChrCounts <- table(clusters[[clusterNum]]$chr)
  clusterName <- sprintf('Cluster%03d', clusterNum)
  for( chr in 1:25 ){
    category <- sprintf('Chr%d', chr)
    freq <- clusterChrCounts[ as.character(chr) ]
    if( freq <= 5 ){
      cat(paste(clusterName, category, sep=", "), ": Too few Genes...", freq, ". Skipping...\n")
    } else{
      prob <- probs[ as.character(chr) ]
      clusterSize <- nrow(clusters[[clusterNum]])
      ChrTestRes[[i]] <- binomTest( freq, clusterSize, prob, clusterName, category )
      i <- i + 1
    }
  }
}
```

```{r adjpvalue, include=TRUE}
# This joins together all the test results and adjusts the p values to account for multiple testing
ChrTestResults <- do.call( rbind, ChrTestRes )
ChrTestResults_adjPvalues <- qvalue( ChrTestResults$p.value, fdr = 0.05 )
ChrTestResults$adj.p.value <- ChrTestResults_adjPvalues$qvalues
ChrTestResults$log2FE <- log2(ChrTestResults$Count/ChrTestResults$Expected)
sigClustersFilter <- ChrTestResults_adjPvalues$significant & ChrTestResults$log2FE > 1
sigResults <- data.frame(
  Cluster = ChrTestResults$Cluster[ sigClustersFilter ],
  Chromosome = ChrTestResults$Category[ sigClustersFilter ],
  Count = ChrTestResults$Count[ sigClustersFilter ],
  Expected = round(ChrTestResults$Expected[ sigClustersFilter ], digits = 2 ),
  log2FE = round( ChrTestResults$log2FE[ sigClustersFilter ], digits = 2 ),
  # pvalue = sprintf('%.3e', ChrTestResults$p.value[sigClustersFilter] ),
  "Adjusted pvalue" = sprintf('%.3e', ChrTestResults$adj.p.value[sigClustersFilter] )
)
# sort by chr name
sigResults <- sigResults[ order( sigResults$Chromosome ), ]

kable( sigResults, row.names = FALSE, align = c('l', 'l', 'r', 'r', 'r', 'r', 'r') )

```

Table showing clusters with significant chr enrichments (adjusted p-value < 0.05 and log2 fold change > 1).

# Chr 4 Zinc Finger Genes 
```{bash pfamInfo}
###################################
## GET PFAM INFO
###################################

# Check for existence of Pfma file
# If not download it from EBI
pfamMappingFile='pdb_pfam_mapping.txt'
pfamFTPLink='ftp://ftp.ebi.ac.uk/pub/databases/Pfam/mappings/pdb_pfam_mapping.txt'

# check for PFAM file
if [[ ! -e $pfamMappingFile ]]
then
  # download from EBI
  curl -O $pfamFTPLink
  mv $pfamMappingFile dataFiles/$pfamMappingFile
fi
```

```{r getPFAMdomains}
# get Pfam ID to Description
pfamMappingFile <- file.path(rootPath, 'dataFiles', 'pdb_pfam_mapping.txt')
pfamMapping <- read.table(file=pfamMappingFile, sep="\t", header=TRUE)
# make named vector of IDs to Description
pfamDesc <- data.frame(
  pfam = gsub("\\.[0-9]+", "", pfamMapping$PFAM_ACC ),
  pfamDescription = pfamMapping$PFAM_desc
)
# limit to unique rows
pfamDesc <- unique(pfamDesc)
```

```{r get_chr4_genes}
chr4Region = list( chr = "4", start = 24000000, end = NULL )

# connect to ensembl
# need the correct archive site 85 = jul2016.archive.ensembl.org
# to connect to the current database use
# ensBiomart <- useMart( "ensembl", dataset="drerio_gene_ensembl")
ensBiomart <- useMart(host='jul2016.archive.ensembl.org', biomart = "ENSEMBL_MART_ENSEMBL", dataset="drerio_gene_ensembl")

#' getGenesForRegion
#' Function to extract the genes within a genomic range
#' 
#' Performs a binomial test given the observed frequency, group size, 
#'    probability of chosen from the category at random and a category name
#'    
#' @param chr character, name of the chromosome
#' @param start integer, start of the region (default: 1)
#' @param end integer, end of the region (default: max position for the chr in the data)
#' @param AllGenesInfo data.frame, name of the cluster from which the observed counts come
#'
#' @return data.frame, gene info from Ensembl with geneId, gene name, chr, start and end
#'
getGenesForRegion <- function(chr, start = 1, end = NULL, AllGenesInfo){
  if( is.null( end ) ){
    end <- max( AllGenesInfo$end_position[ AllGenesInfo$chromosome_name == chr ] )
  }
  chr_specific_genes <- AllGenesInfo[ AllGenesInfo$chromosome_name == chr & 
                                 AllGenesInfo$start_position >= start & 
                                 AllGenesInfo$end_position <= end, ]
  return( chr_specific_genes )
}

#' getGenesAndPfam
#' Function to extract the genes within a genomic range and get
#'    information on PFAM domains
#' 
#' Retrieves PFAM domain information for the genes within the supplied genomic interval 
#'    
#' @param biomartObj, biomaRt object from connecting to Ensembl bioMart
#' @param chr character, name of the chromosome
#' @param start integer, start of the region (default: 1)
#' @param end integer, end of the region (default: max position for the chr in the data)
#' @param pfamDesc data.frame, mapping of PFAM accession numbers to descriptions
#'
#' @return data.frame, contains information on the genes and the associated PFAM domains
#'
getGenesAndPfam <- function( biomartObj, chr, start = 1, end = NULL, pfamDesc ){
  chr_specific_genes <- getGenesForRegion(chr, start = start, end = end, AllGenesInfo)
  # get gene/Pfam info from Biomart
  genes_Pfam_domains <- getBM( 
    filters = "ensembl_gene_id",
    attributes = c('ensembl_gene_id', 'external_gene_name', 'pfam'),
    values = as.character( chr_specific_genes$ensembl_gene_id ),
    mart = ensBiomart
  )
  # merge to Descriptions and get unqiue rows
  Pfam_plusDesc <- merge(genes_Pfam_domains, pfamDesc)
  Pfam_plusDesc <-  unique(Pfam_plusDesc[ , 1:4 ])
  return(Pfam_plusDesc)
}

chr4_genes_Pfam <- getGenesAndPfam( ensBiomart, chr4Region$chr, 
                                    chr4Region$start, chr4Region$end, 
                                    pfamDesc )

# get zinc finger genes
chr4_ZnF_genes <- chr4_genes_Pfam[ grepl("[zZ]inc.finger", chr4_genes_Pfam$pfamDescription), ]
# join to AllGenesInfo
chr4_ZnF_geneInfo <- merge(AllGenesInfo, chr4_ZnF_genes)
chr4_ZnF_geneInfo <- chr4_ZnF_geneInfo[ order(chr4_ZnF_geneInfo$start_position), ]
chr4ZnFData <- unique(chr4_ZnF_geneInfo[ , 1:5 ])
```

```{r chr4_ZnF, include=TRUE}
# ZnF genes in clusters
ZnFs <- clusterData[ as.character(chr4ZnFData$ensembl_gene_id), ]
ZnFs <- ZnFs[ !is.na(ZnFs$name), ]
clusterCounts <- as.data.frame( table( ZnFs$cluster ) )
colnames(clusterCounts)[1] <- "Cluster"
clustersOverFive <- clusterCounts[ clusterCounts$Freq >= 5, ]
kable( clustersOverFive[ order(clustersOverFive$Freq, decreasing = TRUE ), ] )
```

Table showing the numbers of chromosome 4 zinc finger genes in the biolayout clusters (more than 5 in a cluster).

## Chr 4 ZnF enrichment

The table below shows the clusters with enrichments significantly larger than expected by chance for the chromosome 4 zinc finger genes.

```{r binomChr4ZnF}
# prob is number of Chr 4 ZnF genes / total genes
TestRes <- vector( "list", length = length(levels(clusterCounts$Cluster)) )
i <- 1
prob <- nrow(ZnFs) / nrow(clusterData)
for( clusterName in levels(clusterCounts$Cluster) ){
  freq <- clusterCounts$Freq[ clusterCounts$Cluster == clusterName ]
  if( freq < 4 ){
    cat(clusterName, ": Too few Genes...", freq, ". Skipping...\n")
  } else{
    clusterSize <- nrow(clusterData[clusterData$cluster == clusterName, ])
    TestRes[[i]] <- binomTest( freq, 
                               clusterSize, prob, clusterName, 'Chr4ZnF' )
    i <- i + 1
  }
}
```

```{r chr4ZnF_enrichment, include=TRUE}
TestResults <- do.call( rbind, TestRes )
TestResults_adjPvalues <- p.adjust(TestResults$p.value, method = "bonferroni" )
TestResults$adj.p.value <- TestResults_adjPvalues
SigClusters <- TestResults[ TestResults_adjPvalues < 0.05, ]

sigClusterResults <- data.frame(
  Cluster = SigClusters$Cluster,
  Category = SigClusters$Category,
  Count = SigClusters$Count,
  Expected = round(SigClusters$Expected, digits = 2 ),
  log2FE = round( log2( SigClusters$Count / SigClusters$Expected ), digits = 2 ),
  pvalue = sprintf('%.3e', SigClusters$p.value ),
  adjusted.pvalue = sprintf('%.3e', SigClusters$adj.p.value )
)
kable( sigClusterResults, row.names = FALSE, align = c('l', 'l', 'r', 'r', 'r', 'r', 'r') )

```

Table showing clusters with significant enrichments (adjusted p-value < 0.05).

```{r funcs}
#' cluster_and_plot_tpms
#' Function to cluster supplied tpm matrix and plot a heatmap
#' 
#' Takes a matrix and clusters and plots a ggplot2heatmap
#'    
#' @param tpms matrix, matrix of TPM, rows are genes, columns are samples
#' @param row integer, rows to subset to
#' @param columns integer, columns to subset to
#' @param cluster logical, whether to cluster the rows or not
#' @param plot logical, whether to create heatmap plot or not
#' @param distance_measure character, distance measure to use
#' @param reverseGenes logical, whether to reverse the gene order for plotting
#'
#' @return list, containing tpm, tpm.m, plot, tree
#'
cluster_and_plot_tpms <- function( tpms, rows = NULL, columns = 1:90, cluster = TRUE, plot = TRUE, distance_measure = "pearson", reverseGenes = FALSE ){
  # subset to supplied rows and columns
  # 
  if( class(columns) != "integer" ){
    stop('The columns argument is not an integer vector!')
  }
  if( !is.null(rows) ){
    if( class(rows) != "character" ){
      stop('The rows argument is not a character vector!')
    } else {
      tpmMat <- tpms[ rows, columns ]
    }
  } else {
    tpmMat <- tpms[ , columns ]
  }
  
  # cluster genes
  if( cluster ){
    if( distance_measure == "pearson" ){
      distMatrix <- as.dist( 1 - abs( cor(t(tpmMat)) ) )
    } else{
      distMatrix <- dist(tpmMat, method = "euclidean")
    }
    
    # cluster and reorder correlation matrix
    hClust <- hclust(distMatrix, method = "complete")
    
    # find optimal ordering of leaves
    optOrder <- order.optimal(distMatrix, hClust$merge)
    
    # plot tree and cor matrix
    newClust <- hClust
    newClust$merge <- optOrder$merge
    newClust$order <- optOrder$order
    
    # order genes by optimal ordering
    tpmMat <- tpms[ newClust$order, ]
  }
  
  if( plot ){
    if( reverseGenes ){
      gene_idLevels <- rev( row.names(tpmMat) )
    } else{
      gene_idLevels <- row.names(tpmMat)
    }
    if( class(tpmMat) == "data.frame" ){
      tpmMat <- as.matrix(tpmMat)
    }
    
    tpms.m <- melt( tpmMat, variable.name = "sample")
    colnames(tpms.m) <- c("gene_id", "sample", "value")
    tpms.m$gene_id <- factor( tpms.m$gene_id,
                              levels = gene_idLevels )
    
    tpmHeatmap <- ggplot(data = tpms.m) + 
      geom_raster( aes( x = sample, y = gene_id, fill = value ) ) + 
      scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                            guide = guide_colorbar(title = "TPM\n(max scaled)") ) + 
      theme_void() + theme( legend.position="left",
                            legend.title = element_text(colour="black" ) )
  }
  
  returnList <- list(
      tpms = tpmMat,
      tpms.m = NULL,
      plot = NULL,
      tree = NULL
  )
  if( plot ){
    returnList$tpms.m <- tpms.m
    returnList$plot <- tpmHeatmap
  }
  if( cluster ){
    returnList$tree <- newClust
  }
  return( returnList )
}
```

```{r set_colour_palette}
colPalette <- c(
  "Cluster001" = "#F3756D", 
  "Cluster002" = "#D69029", 
  "Cluster003" = "#36AAE1",
  "Cluster004" = "#94A3BE",
  "Cluster005" = "#16BCC2",
  "Cluster006" = "#8D8CC4",
  "Cluster009" = "#ED66A6",
  "Cluster022" = "#5EBB47",
  "Cluster037" = "#97543B",
  "Cluster084" = "#363A4D"
)
```

```{r znf_log10TPM_heatmap, include=TRUE}
# get TPMs for just ZnFs from clusters 4, 22, 37 and 84
clusterNums <- c(4,22,37,84)
clusterNames <- sprintf("Cluster%03d", clusterNums)
cl4_22_37_84_ZnFsList <- lapply(as.list(clusterNames), 
                                      function(name, ZnFs){ 
                                        rownames(ZnFs)[ ZnFs$cluster == name ] },
                                      ZnFs
                              )
get_tpms_by_geneIds <- function( geneIds ){
  tpmSubset <- tpm[ geneIds, ]
  tpmSubset <- tpmSubset[ !(grepl("NA", rownames(tpmSubset))), ]
  return( tpmSubset )
}
cl4_22_37_84_ZnFsTpmList <- lapply( cl4_22_37_84_ZnFsList, get_tpms_by_geneIds )
cl4_22_37_84_ZnFsTpmInfoList <- vector( 'list', length=length(cl4_22_37_84_ZnFsList) )

# cluster genes within each biolayout cluster
# then join together to plot
for(i in seq_len(length(cl4_22_37_84_ZnFsList)) ){
  cl4_22_37_84_ZnFsTpmInfoList[[i]] <- 
    cluster_and_plot_tpms(log10(cl4_22_37_84_ZnFsTpmList[[i]]+1) )
}

cl4_22_37_84ZnFslog10Tpm <- do.call( rbind, 
                            lapply(cl4_22_37_84_ZnFsTpmInfoList, function(x){ x$tpms } ) )

cl4_22_37_84_ZnF_tpmsInfo <- cluster_and_plot_tpms( cl4_22_37_84ZnFslog10Tpm, 
                                                    cluster = FALSE,
                                                    reverseGenes = TRUE )
# make a dataframe for plotting cluster membership
cl4_22_37_84_annoData <- data.frame(
  geneId = factor( rownames(cl4_22_37_84_ZnF_tpmsInfo$tpms),
                   levels = rev( rownames(cl4_22_37_84_ZnF_tpmsInfo$tpms) ) ),
  cluster = c( rep("Cluster004", nrow(cl4_22_37_84_ZnFsTpmList[[1]]) ),
               rep("Cluster022", nrow(cl4_22_37_84_ZnFsTpmList[[2]]) ),
               rep("Cluster037", nrow(cl4_22_37_84_ZnFsTpmList[[3]]) ),
               rep("Cluster084", nrow(cl4_22_37_84_ZnFsTpmList[[4]]) ) 
               ),
  AnnoType = rep( "Cluster", nrow(cl4_22_37_84_ZnF_tpmsInfo$tpms) )
)
# tile plot of cluster membership
cl4_22_37_84_ClusterTilePlot <- ggplot( data = cl4_22_37_84_annoData, aes(x=AnnoType, y=geneId, fill=cluster) ) + 
  geom_tile() + scale_y_discrete(labels=NULL) + 
  scale_x_discrete(labels=NULL) + 
  scale_fill_manual( values = colPalette, na.value = "white") + theme_void()

```

```{r NLR_log10_tpms}
nlrFile <- file.path(rootPath, 'dataFiles', 'rnaseq', 'NLR-ENS-GRCz10.txt')
nlrData <- read.table(nlrFile)
colnames(nlrData) <- c("geneID")
nlrRawtpms <- tpm[ as.character(nlrData$geneID), ]
nlrlogtpms <- log10( nlrRawtpms + 1 )
nlrlogtpmsInfo <- cluster_and_plot_tpms( nlrlogtpms, cluster = FALSE )
```

```{r }
#' plotExprByChr
#' Plot the expression of genes from a section (or all) of chromosome
#' 
#' Takes a genomic interval as chr, start, end and plots an expression heatmap
#'    using the supplied matrix
#'
#' @param chr character, name of the chromosome
#' @param start integer, start of the region (default: 1)
#' @param end integer, end of the region (default: max position for the chr in the data)
#' @param tpm matrix, matrix of TPM, rows are genes, columns are samples
#' @param position logical, whether to plot genomic positions on the y-axis
#'
#' @return list, containing tpms, plot
#'
plotExprByChr <- function( chr, start = 1, end = NULL, position = TRUE, tpm = tpmByStageClustered ){
  chr_specific_genes <- getGenesForRegion(chr, start = start, end = end, AllGenesInfo)
  # sort by position
  chr_specific_genes <- chr_specific_genes[ order(chr_specific_genes$start_position), ]
  
  geneStarts <- chr_specific_genes$start_position
  names(geneStarts) <- chr_specific_genes$ensembl_gene_id
  
  chr_specific_tpms <- as.data.frame(tpm)[ as.character( chr_specific_genes$ensembl_gene_id ), ]
  chr_specific_tpms <- chr_specific_tpms[ !(grepl("NA", rownames(chr_specific_tpms))), ]
  log10chr_specific_tpms <- log10(chr_specific_tpms+1)
  geneStarts <- geneStarts[ rownames(chr_specific_tpms) ]
  
  chr_specific_tpmsUnclustered <- cluster_and_plot_tpms( log10chr_specific_tpms, cluster = FALSE )
  
  # plot tpms ordered by chr location
  chr_string <- paste0('Expression across chromosome', chr)
  chr_specific_tpmsUnclusteredPlot <- chr_specific_tpmsUnclustered$plot
  if( position ){
    if( length(geneStarts) > 100 ){
      chr_specific_tpmsUnclusteredPlot <- chr_specific_tpmsUnclusteredPlot +
        scale_y_discrete( breaks = names(geneStarts[ seq(100,length(geneStarts),100) ]),
                          labels = paste0("Chr", chr, ":", as.character( round( geneStarts[ seq(100,length(geneStarts),100) ]/1000000, digits=1 ) ) ) ) 
    } else if( length(geneStarts) > 10 ){
      chr_specific_tpmsUnclusteredPlot <- chr_specific_tpmsUnclusteredPlot +
        scale_y_discrete( breaks = names(geneStarts[ seq(10,length(geneStarts),10) ]),
                          labels = paste0("Chr", chr, ":", as.character( round( geneStarts[ seq(10,length(geneStarts),10) ]/1000000, digits=1 ) ) ) ) 
    }
  }
    
  chr_specific_tpmsUnclusteredPlot <- chr_specific_tpmsUnclusteredPlot +
    theme( axis.text.y = element_text(colour="black"),
          axis.ticks.y = element_line( colour="black"),
          legend.position="left",
          legend.title = element_text(colour="black" ),
          plot.title = element_text(colour="black" ) ) + 
    labs(title = chr_string) + 
    guides( fill = guide_colorbar(title = "log10\nTPM") )
  return( 
    list( tpms = chr_specific_tpms,
          plot = chr_specific_tpmsUnclusteredPlot )
  )
}
```

```{r znfs_22, include=TRUE}
znfs_22Region = list( chr = "22", start = 1900000, end = 2900000 )
znfs_22 <- plotExprByChr( znfs_22Region$chr, znfs_22Region$start, znfs_22Region$end )

# get gene info from biomart
znfs_22Pfam <- getGenesAndPfam( ensBiomart, znfs_22Region$chr, 
                                znfs_22Region$start, znfs_22Region$end, 
                                pfamDesc )
# join to AllGenesInfo
znfs_22PfamInfo <- merge(AllGenesInfo, znfs_22Pfam, 
                       by.x = c('ensembl_gene_id'), by.y = c('ensembl_gene_id') )

znfs_22PfamInfo <- znfs_22PfamInfo[ order( znfs_22PfamInfo$start_position), 
                                      c('ensembl_gene_id', 'external_gene_name.y', 
                                        'chromosome_name',
                                        'start_position', 'end_position',
                                        'pfam', 'pfamDescription') ]
names(znfs_22PfamInfo)[ grepl("external_gene_name.y", names(znfs_22PfamInfo)) ] <- 'external_gene_name'

```

```{r all_chr4_genes, include=TRUE}
chr4_GeneExprList <- plotExprByChr( '4' )
```

```{r chr4Expr_plus_cluster, include=TRUE}
chr4ClusterData <- droplevels( clusterData[ rownames(chr4_GeneExprList$tpms), c("cluster", "start") ] )
chr4ClusterData$geneId <- factor( rownames(chr4_GeneExprList$tpms),
                                  levels = rownames(chr4_GeneExprList$tpms) )
rownames(chr4ClusterData) <- rownames(chr4_GeneExprList$tpms)

for( clusterName in names(table(chr4ClusterData$cluster))[ table(chr4ClusterData$cluster) <= 8 ] ){
  chr4ClusterData$cluster[ chr4ClusterData$cluster == clusterName ] <- NA
}
chr4ClusterData <- droplevels(chr4ClusterData)

chr4ClusterTilePlotMultiTrack <- ggplot( data = chr4ClusterData, aes(x=cluster, y=geneId, fill=cluster) ) + 
  geom_tile() + scale_y_discrete(labels=NULL) + 
  scale_x_discrete(labels=NULL) + 
  scale_fill_manual(values = colPalette, na.value = "white") + theme_void()

```

### Fig4A

```{r plotfig4a, include=TRUE, warning=FALSE}
# figure out max expression level
maxValue <- round( max( log10(chr4_GeneExprList$tpms+1), 
                        cl4_22_37_84_ZnF_tpmsInfo$tpms, 
                        nlrlogtpmsInfo$tpms, 
                        log10(znfs_22$tpms+1) ), 
                   digits = 1 )

## CLUSTER 4,22,37 & 84 TPMs + cluster membership
# arrange the two plots together
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = list( cl4_22_37_84_ZnF_tpmsInfo$plot + 
                               scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ),
                             cl4_22_37_84_ClusterTilePlot ), 
               nrow = 1,
               widths=c(0.78,0.22)
              )
)

# output to pdf
pdf(file=file.path(rootPath, 'plots',
                          'Figure.4a.pdf') )
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = list( cl4_22_37_84_ZnF_tpmsInfo$plot + 
                               scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ),
                             cl4_22_37_84_ClusterTilePlot ), 
               nrow = 1,
               widths=c(0.78,0.22)
              )
)
dev.off()

```

### Fig4C - NLR genes tpm heatmap

```{r plotfig4c, include=TRUE, warning=FALSE}
print( nlrlogtpmsInfo$plot + scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ) )

pdf(file=file.path(rootPath, 'plots', 'Figure.4c.pdf'))
print( nlrlogtpmsInfo$plot + scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ) )
dev.off()
```

### Fig4D - Chr22 Znf genes tpm heatmap
```{r fig4d, include=TRUE, warning=FALSE}
# ZnF chr 22 plot
print( znfs_22$plot + 
         scale_fill_gradientn( limits = c(0,maxValue),
                                colours = c("blue", "yellow", "red"),
                                guide = guide_colorbar(title = "log10 TPM") ) +
         theme(plot.title=element_blank()) )

# plot to file
pdf(file=file.path(rootPath, 'plots', 'Figure.4d.pdf'))
print( znfs_22$plot + 
         scale_fill_gradientn( limits = c(0,maxValue),
                                colours = c("blue", "yellow", "red"),
                                guide = guide_colorbar(title = "log10 TPM") ) +
         theme(plot.title=element_blank()) )
dev.off()

```

### Fig4E - Chr4 tpm heatmap
```{r chr4_plot, include=TRUE, warning=FALSE}
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = list( chr4_GeneExprList$plot + 
                               theme(plot.title=element_blank()) +
                               scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ),
                             chr4ClusterTilePlotMultiTrack ),
               nrow = 1,
               widths=c(0.7,0.3)
              )
)

pdf(file=file.path(rootPath, 'plots', 'Figure.4e.pdf'))
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = list( chr4_GeneExprList$plot + 
                               theme(plot.title=element_blank()) +
                               scale_fill_gradientn( limits = c(0,maxValue),
                                 colours = c("blue", "yellow", "red"),
                                  guide = guide_colorbar(title = "log10 TPM") ),
                             chr4ClusterTilePlotMultiTrack ),
               nrow = 1,
               widths=c(0.7,0.3)
              )
)
dev.off()
```

### Fig4F-G - histograms of ZnF/NLR genes on chr 4
```{r hist, include=TRUE}
plotData <- merge( chr4ZnFData, clusterData, by.x = "ensembl_gene_id", by.y = "gene_id" )
plotData$mid <- plotData$start + (plotData$end - plotData$start)/2

histData <- rbind(
  plotData[ plotData$cluster == "Cluster004", ],
  plotData[ plotData$cluster == "Cluster022", ],
  plotData[ plotData$cluster == "Cluster037", ],
  plotData[ plotData$cluster == "Cluster084", ]
)

ZnF_hist <- ggplot( data = histData ) +
  geom_histogram( aes( x = mid ), binwidth = 5000000, colour = "white" ) + 
  labs(x = 'Position (Mb)', y = "Gene Count") + 
  scale_x_continuous(limits=c(0,80000000)) + theme_minimal()

plotList <- add_to_plot_list( plotList, ZnF_hist, 
                              file.path(file.path(rootPath, 'plots', 'Figure.4f.pdf')) )

print(ZnF_hist)
```

Histogram showing the distribution of genes in clusters 4, 22, 37 and 84.

```{r nlr_dist, include=TRUE}
# merge NLR gene ids to AllGenesInfo to subset to NLR genes
nlrGeneInfo <- merge(AllGenesInfo, nlrData, by.x = "ensembl_gene_id", by.y = "geneID")
# subset to chr 4
chr4nlrGeneInfo <- nlrGeneInfo[ nlrGeneInfo$chromosome_name == '4', ]

chr4nlrGeneInfo$mid <- chr4nlrGeneInfo$start_position + (chr4nlrGeneInfo$end_position - chr4nlrGeneInfo$start_position)/2

nlrHist <- ggplot( data = chr4nlrGeneInfo ) +
  geom_histogram( aes( x = mid ), binwidth = 5000000, colour = "white" ) +
  scale_x_continuous(limits=c(0,80000000)) +
  theme_minimal() +
  labs(x = 'Position (Mb)', y = "Gene Count")

plotList <- add_to_plot_list( plotList, nlrHist, 
                              file.path(file.path(rootPath, 'plots', 'Figure.4g.pdf')) )

print(nlrHist)
```

Histogram showing the distribution of NLR genes on chromosome 4 (binwidth = 5 Mb).

### Figure 4-2
#### histograms of ZnF genes on chr 4, split by cluster

```{r hist_facetted, include=TRUE}
histxBreaks <- seq(0,80000000,20000000)
histxLabels <- as.character( seq(0,80,20) )
cl4_22_37_84_hist <- ggplot( data = histData ) +
  geom_histogram( aes( x = mid ), binwidth = 5000000, colour = "white" ) + 
  scale_x_continuous( limits=c(0,80000000), breaks = histxBreaks, labels = histxLabels ) +
  labs(x = 'Position (Mb)', y = "Gene Count") +
  facet_wrap( ~ cluster ) +
  theme_minimal()

plotList <- add_to_plot_list( plotList, cl4_22_37_84_hist, 
                              file.path(rootPath, 'plots', 'Figure.4-2.pdf') )

print(cl4_22_37_84_hist)
```

Histogram showing the distribution of genes in clusters 4, 22, 37 and 84, split by cluster.

#### Regional expression

### Figure 4-3A

```{r manhattan, include=TRUE}
# get chr lengths for seqinfo object
fastaIndexFile <- '~/sanger/lustre/scratch110/sanger/rw4/genomes/Dr/GRCz10/striped/Danio_rerio.GRCz10.dna.toplevel.fa.fai'
faidx <- read.table(file=fastaIndexFile, sep="\t", 
                    colClasses=c("character", "integer", "integer", "integer", "integer"))
names(faidx) <- c("Chr", "Length", "Idx", "LineLength", "LineLength2")
GRCz10Chrs <- Seqinfo( seqnames=faidx$Chr, seqlengths=faidx$Length )
# subset to just chr, remove scaffolds
GRCz10Chrs <- keepSeqlevels(GRCz10Chrs, as.character(1:25))
genome(GRCz10Chrs) <- 'GRCz10'

# sort tpm by Chr and by Start
tpmChrSorted <- tpmAnno[ order(tpmAnno$Chr, tpmAnno$Start), ]

# make GRanges object
GenesGR <- GRanges(
  seqnames = Rle(tpmChrSorted$Chr),
  ranges = IRanges(start = tpmChrSorted$Start, end = tpmChrSorted$End),
  strand = Rle(tpmChrSorted$Strand),
  GeneId = rownames(tpmChrSorted)
)

# function to calculate average pair-wise correlation
# returns a data.frame with the info to create a GRanges object
average_pairwise_sim <- function(index, gr, sim, chr, start_indices, end_indices, num_coeffs){
  start_index <- start_indices[index]
  end_index <- end_indices[index]
  cor_coeffs <- numeric( length = num_coeffs )
  coeff_i <- 1
  for( i in start_index:(end_index - 1) ){
    cor_coeffs[coeff_i:(coeff_i - 1 + end_index - i)] <- sim[(i + 1):end_index, i ]
    coeff_i <- coeff_i + end_index - i
  }
  
  return(
    data.frame(
      chr = chr,
      start = start(gr)[start_index], 
      end = end(gr)[end_index],
      strand = '+',
      avSim = mean(cor_coeffs)
    )
  )
}

# split GRanges by chr
GenesGRbyChr <- split(GenesGR, seqnames(GenesGR))
windowSize <- 10
# list to store the GRanges object
avSimbyChr <- vector('list', length = 25 )
names(avSimbyChr) <- names(GenesGRbyChr)[1:25]
for( chr in names(GenesGRbyChr)[1:25] ){
  gr <- GenesGRbyChr[[chr]]
  data <-  tpmChrSorted[ tpmChrSorted$Chr == chr, ]
  sim <- cor(t(data[ , 9:98 ]))
  start_indices <- seq_len(length(gr)+1-windowSize)
  end_indices <- start_indices + windowSize - 1
  num_coeffs <- windowSize * (windowSize - 1)/2
  avSim <- lapply(seq_len(length(start_indices)),
                  average_pairwise_sim,
                  gr, sim, chr, start_indices, end_indices, num_coeffs)
  avSim <- do.call(rbind, avSim)
  # make new GRanges object
  avSimbyChr[[chr]] <- GRanges(
    seqnames = Rle(avSim$chr),
    ranges = IRanges(start = avSim$start, end = avSim$end),
    strand = Rle(avSim$strand),
    seqinfo = GRCz10Chrs,
    avSim = avSim$avSim,
    mid_point = start_indices + (end_indices - start_indices) / 2
  )
}
# make GRangesList and concat
avSimGRL <- GRangesList(avSimbyChr)
avSimGR <- unlist(avSimGRL)
# add seqinfo
seqinfo(avSimGR) <- GRCz10Chrs

simThreshold <- 0.5
manhattanPlot <- 
  plotGrandLinear(avSimGR, aes(y = avSim), color = c('grey70', 'grey40')) + 
  geom_hline( yintercept = simThreshold, colour = 'firebrick3', linetype = 2 ) + 
  labs(x = 'Chromosome', y = 'Mean Pair-wise Correlation Coefficient') +
  theme_minimal() + theme(legend.position = 'none')

print(manhattanPlot)
```

```{r manhattan_plot, echo=FALSE}
postscript(file = file.path(rootPath, 'plots', 'Fig.4a.eps'),
           width = 12, height = 4, paper = 'special')
print(
  plotGrandLinear(avSimGR, aes(y = avSim), 
                  color = c('grey70', 'grey40'), size = 0.5) + 
  geom_hline( yintercept = simThreshold, colour = 'firebrick3', linetype = 2 ) + 
  labs(x = 'Chromosome', y = 'Mean Pair-wise Correlation Coefficient') +
  theme_minimal() + theme(legend.position = 'none')
)
dev.off()

```

```{r regional_expr_plot, include=TRUE}
# make a chromosomal order plot for every chromosome
chrSpecificGeneExprList <- lapply( seq_len(25),
                                   plotExprByChr, tpm = tpmFilt )
names(chrSpecificGeneExprList) <- as.character(1:25)

# print without y axis labels and legend
# remove the position labels and unify colour scale across chrs
maxtpm <- log10( max( sapply(chrSpecificGeneExprList, function(x){ max( x$tpms ) } ) ) )

# plot chr heatmap and similarity measure together
chrSpecificGeneExprPlotNoLegendList <- vector('list', length = 25)
names(chrSpecificGeneExprPlotNoLegendList) <- as.character(1:25)
scaled_threshold <- -100 + simThreshold * 100
for( chr in as.character(1:25) ){
  cat( sprintf('Chr %d', chr) )
  plot_data <- as.data.frame(mcols(avSimGRL[[chr]]))
  plot_data$score_scaled <- -100 + plot_data$avSim * 100
  chrSpecificGeneExprPlotNoLegendList[[chr]] <-
    chrSpecificGeneExprList[[chr]]$plot +
      geom_path(data = plot_data, aes(x = score_scaled, y = mid_point), size = 0.12) + 
      geom_vline( xintercept = scaled_threshold, colour = "firebrick3", size = 0.25) +
      scale_fill_gradientn( limits = c(0,maxtpm),
                            colours = c("blue", "yellow", "red") ) + 
      theme(plot.title = element_blank(),
            axis.text.y = element_blank(),
            legend.position="none")
  print(chrSpecificGeneExprPlotNoLegendList[[chr]])
}

# resize each plot based on the number of genes for that chromosome 
heights <- sapply( chrSpecificGeneExprList, function(x){ nrow( x$tpms) } )
plotHeights <- heights/max(heights)

for( i in seq_len(length(chrSpecificGeneExprPlotNoLegendList)) ){
  postscript(file=file.path(rootPath, 'plots', paste0('Figure.4-3.chr', i, '.chr-order.eps') ),
      width=1.5,height=24*plotHeights[i], paper = "special")
  print(chrSpecificGeneExprPlotNoLegendList[[i]])
  dev.off()
  
  print(chrSpecificGeneExprPlotNoLegendList[[i]])
}

# print one with a legend to get the legend
postscript(file=file.path(rootPath, 'plots', paste0('Figure.4-3.chr1.chr-order.pluslegend.eps') ))
chrSpecificGeneExprList[[1]]$plot + 
  scale_fill_gradientn( limits = c(0,maxtpm),
  colours = c("blue", "yellow", "red") )
dev.off()
```

### Get Peaks

```{r collect_hits, include=TRUE}
findHits <- function( chr, tpmChrSorted, chrSimList, windowSize, simThreshold ){
  # cat(sprintf('Chr: %s\n', chr))
  # get plot Data
  plotData <- chrSimList[[chr]]
  data <-  tpmChrSorted[ tpmChrSorted$Chr == chr, ]
  # go through and aggregate runs that exceed the threshold
  prevAboveThreshold <- FALSE
  runsList <- vector( 'list' )
  runsListIndex <- 1
  runStart <- 0
  i <- 1
  for( aboveThreshold in plotData$avSim >= simThreshold ){
    if( !prevAboveThreshold & !aboveThreshold ){
      # between runs, carry on
    } else if( prevAboveThreshold & !aboveThreshold ){
      # end of a run
      dataSubset <- data[ runStart:(i+windowSize-1), ]
      runsList[[ runsListIndex ]] <- dataSubset
      # cat( dim(dataSubset), "\n" )
      runsListIndex <- runsListIndex + 1
    } else if( !prevAboveThreshold & aboveThreshold ){
      # start of a new run
      runStart <- i
    } else{
      # in a run, carry on
    }
    # cat( paste(prevAboveThreshold, aboveThreshold, 
               # i, runStart, runsListIndex,
               # sep="\t"), "\n" )
    prevAboveThreshold <- aboveThreshold
    i <- i + 1
  }
  # go through peaks and merge overlapping regions
  if ( length(runsList) == 0 ){
    return( NULL )
  } else if( length(runsList) > 1 ){
    mergedList <- vector('list')
    mergedListIndex <- 1
    i <- 1
    current_region <- runsList[[i]] # this is the first region
    i <- 2
    while(i <= length(runsList)){
      # cat('i:', i, "\n")
      next_region <- runsList[[i]]
      # compare the current region to the next one
      if ( next_region$Start[1] <= current_region$End[nrow(current_region)] ) {
        # if they overlap merge them, set current region to the merged region
        overlap <- TRUE
        current_region <- 
          rbind( current_region,
                 next_region[ setdiff(rownames(next_region), rownames(current_region)), ] )
        i <- i + 1
      } else {
        # if they don't, add the current region to the list and set the next region to be the new current region
        overlap <- FALSE
        mergedList[[mergedListIndex]] <- current_region
        mergedListIndex <- mergedListIndex + 1
        current_region <- next_region
        i <- i + 1
      }
    }
    # check the status of the overlap
    # if the last 2 regions overlapped add the current region to the list
    # if not add next region
    if (overlap) {
      mergedList[[mergedListIndex]] <- current_region
    } else {
      mergedList[[mergedListIndex]] <- next_region
    }
    # return
    return(mergedList)
  } else {
    return(runsList)
  }
}

plotSubset <- function( dataSubset, chr ){
  exprMatrix <- as.matrix(log10(dataSubset[,8:97]+1))
  # reverse rows of matrix
  exprMatrix <- exprMatrix[seq(nrow(exprMatrix),1,-1), ]
  rowLabels <- rev(as.character(dataSubset$GeneName))

  # put chr and region on plot
  title_text <- paste0('Chr ', chr, ' (', dataSubset$Start[1], '-', dataSubset$End[length(dataSubset$End)], ')')
  heatmap <- ggplotExprHeatmap( exprMatrix, rowLabels = rowLabels ) +
              labs(title = title_text ) + 
              theme( axis.text.y = element_text( colour = "black", angle = 0, debug = FALSE),
                     plot.title = element_text( colour = "black", angle = 0, debug = FALSE) )
  return(heatmap)
}

outputResults <- function(chr, peaksList){
  # cat(chr, "\n")
  dataList <- peaksList[[chr]]
  plotList <- lapply(dataList, plotSubset, chr)
  for( peakNum in seq_len(length(dataList))){
     file <- file.path(outputDir, paste0('chr', chr, '-peak', peakNum, '.tsv') )
     write.table(dataList[[peakNum]][,1:7], file=file, sep="\t", row.names = TRUE, col.names = TRUE, quote = FALSE)
  }
  return( plotList )
}

# simThreshold is defined in block `plot_similarity`
windowSize <- 10
peaksList <- lapply( seq_len(25), findHits, 
                     tpmChrSorted, chrSimList, 
                     windowSize, simThreshold )

plots <- lapply( seq_len(25), outputResults, peaksList )
plots

```

```{r fig.4.3b-g, include=TRUE}
selectedRegions <- list(
  crystallins = list( chr = "9", start = 22082881, end = 22866634 ),
  cathepsins = list( chr = "12", start = 16470000, end = 16800000 ),
  her = list( chr = "11", start = 41354000, end = 41449985 ),
  hist1 = list( chr = "7", start = 5408320, end = 6331233 ),
  hist2.1 = list( chr = "25", start = 34600000, end = 34650000 ),
  hist2.2 = list( chr = "25", start = 35760000, end = 35850000 )
)

closeUpPlotList <- lapply( selectedRegions,
                           function( x ){ return( plotExprByChr( x$chr, x$start, x$end, position = FALSE) ) }
                           )
# get max value
maxValue <- log10( max( sapply( closeUpPlotList, function(x){ return( max(x$tpms) ) } ) ) )

# This function adds gene names to the heatmap
add_gene_names <- function( closeUpInfo ){
  geneLabels <- geneNames[ rownames(closeUpInfo$tpms) ]
  return( closeUpInfo$plot + scale_y_discrete(labels=geneLabels) +
            scale_fill_gradientn( limits = c(0,maxValue),
                                colours = c("blue", "yellow", "red"),
                                guide = guide_colorbar(title = "log10 TPM") ) +
            theme( plot.title = element_blank() ) )
}
closeUpPlots <- lapply( closeUpPlotList, add_gene_names )

print(closeUpPlots)

figLetters <- letters[2:7]
for( i in seq_len(length(closeUpPlots)) ){
  pdf( file = file.path(rootPath, 'plots', paste0('Figure.4-3', figLetters[i], '.pdf') ) )
  print(closeUpPlots[[i]])
  dev.off()
}
```

```{r produceGeneLists}
genesPfamList <- lapply( selectedRegions,
                         function(x){
                           return( getGenesAndPfam( ensBiomart, x$chr, 
                                    x$start, x$end, 
                                    pfamDesc ) )
                         }
  )

# join to AllGenesInfo
genesPfamInfo <- lapply( genesPfamList,
                         function(x, AllGenesInfo){ 
                           return( merge(AllGenesInfo, x, by.x = c('ensembl_gene_id'), by.y = c('ensembl_gene_id') ) )
                         },
                         AllGenesInfo
  )

genesPfamInfo <- lapply( genesPfamInfo,
                         function(x){
                           x <- x[ order( x$start_position), 
                                      c('ensembl_gene_id', 'external_gene_name.y', 
                                        'chromosome_name',
                                        'start_position', 'end_position',
                                        'pfam', 'pfamDescription') ]
                           names(x)[ grepl("external_gene_name.y", names(x)) ] <- 'external_gene_name'
                           return(x)
                         }
  )

# join together chr4 znfs, 22 znfs and others and output as file
pfamInfo <- rbind( chr4_ZnF_geneInfo,
                   znfs_22PfamInfo,
                   do.call('rbind', genesPfamInfo )
)

write.table(pfamInfo, file=file.path(rootPath, 'regionalExpression.PFAM.tsv'),
            row.names = FALSE, quote = FALSE, sep=)

```

## Figure 6
### Fig6a
#### Pearson histogram (Paralogues)
```{r load_data}
# one-to-one-paralogues.txt is file produced from Ensembl Biomart
paraloguesFile <- file.path(rootPath, 'dataFiles', 'one-to-one-paralogues.txt' )
colNames <- c("paralogue1ID", "paralogue1Name", "paralogue2Name", "paralogue2ID",
                                "homologyType", "lastCommonAncestor", "gene1.pc.ID", "gene2.pc.ID" )
paraloguesData <- read.table(paraloguesFile, sep="\t",
                             col.names = colNames)
```

```{r correlation, include=TRUE}
# use tpms
data <- tpmFilt
# # or normalised counts
# data <- counts(dds, normalized = TRUE )
# rownames(data) <- mcols(dds)[ , geneIdColumnName ]
# # remove rows that are all zeros
data <- data[ rowSums(data) > 0, ]
geneCor <- cor(t(data))

# for each combination of genes get the correlation coefficient
pairwiseCorList <- lapply( seq_len(nrow(paraloguesData)),
                       function( index ){ 
                         gene1 <- as.character(paraloguesData[ index, "paralogue1ID" ])
                         gene2 <- as.character(paraloguesData[ index, "paralogue2ID" ])
                         # cat( gene1, "\n" )
                         corCoeff <- NA
                         if( sum( rownames(geneCor) == gene1 ) != 1 | 
                             sum( rownames(geneCor) == gene2 ) != 1 ){
                           return(NULL)
                         } else{
                           corCoeff <- geneCor[ gene1, gene2 ]
                         }
                         return( data.frame(
                           gene1 = gene1,
                           gene2 = gene2,
                           CorCoeff = corCoeff )
                         )
                       }
)

pairwiseCor <- do.call( rbind, pairwiseCorList )
pairwiseCor <- pairwiseCor[!is.na(pairwiseCor$CorCoeff),]
pairwiseCor$type <- rep('paralogue_pairs', nrow(pairwiseCor))
```

```{r addGeneNames, eval=FALSE}
# get gene names and add to pairwiseCor
pairwiseCor$gene1Name <- geneNames[ as.character(pairwiseCor$gene1) ]
pairwiseCor$gene2Name <- geneNames[ as.character(pairwiseCor$gene2) ]
```

```{r output}
# ouput list ordered by correlation coeff
pairwiseCorSorted <- pairwiseCor[ order(pairwiseCor$CorCoeff), ]
write.table(pairwiseCorSorted, file = "ZF-Paralogues.pearson.tsv", quote = FALSE, sep="\t", row.names = FALSE )
```

```{r randomCor, include=TRUE}
# plot histogram oif randomly selected gene pairs
set.seed(10927475)
sampleSize <- 3000
row_nums <- sample(seq_len(nrow(geneCor)), sampleSize)
col_nums <- sample(seq_len(nrow(geneCor)), sampleSize)
randomCor <- 
  do.call(rbind,
          lapply(seq_len(sampleSize),
                 function(x, geneCor){
                   data.frame(
                     gene1 = rownames(geneCor)[row_nums[x]],
                     gene2 = rownames(geneCor)[col_nums[x]],
                     CorCoeff = geneCor[row_nums[x], col_nums[x]]
                   )
                 },
                 geneCor
          ) )

randomCor$type <- rep('random_sample', sampleSize)
randomCor$gene1Name <- geneNames[ as.character(randomCor$gene1) ]
randomCor$gene2Name <- geneNames[ as.character(randomCor$gene2) ]

```

```{r corHist, include=TRUE}
# plot histogram
plot_data <- rbind(pairwiseCor, randomCor)
plot_data$type <- factor(plot_data$type, levels = c('random_sample', 'paralogue_pairs'))
CorHist <- ggplot(data = plot_data) + 
  geom_density( aes(x = CorCoeff, fill = type ), colour = NA, alpha = 0.75 ) + 
  scale_fill_manual(values = c('blue', 'red'), 
                    labels = c('Random Sample', 'Paralogue Pairs'),
                    guide = guide_legend(title = NULL)) + 
  labs( x = "Pearson Correlation Coefficient", y = "Density" ) +
  theme_minimal()
medianCor <- median(pairwiseCor$CorCoeff)

print(CorHist)

# plot to eps
pdf(file = file.path(rootPath, 'plots', 'Fig.6a.pdf'),
           width = 8, height = 8, paper = 'special')
print(CorHist)
dev.off()
```

Kernel density estimate of Pearson coefficients between paralogous gene pairs

### Fig6b
#### top10/bottom10 tpm heatmap
```{r plot_functions}
# This function uses ggplotExprHeatmap to plot log10 tpm
plotLog10Heatmap <- function( genes ){
  exprMatrix <- log10( as.matrix( tpm[ as.character( unlist(genes[1,1:2]) ), 1:90 ] ) + 1 )
  ggplotExprHeatmap( exprMatrix )
}

#' getExprData
#' Retrieve expression data for paralogoues gene pairs
#' 
#' Takes a row from the pairwiseCor data.frame and retrieves the expression data.
#'    The TPM can be logged or scaled but not both.
#'    scale is the default, log takes priority
#'
#' @param genes data.frame, expects a row from the pairwiseCor data.frame
#' @param log logical, whether to log the tpms first
#' @param scale logical, whether to center and scale the tpms
#'
#' @return data.frame
#'
getExprData <- function( genes, log = FALSE, scale = TRUE ){
  exprMatrix <- as.matrix( tpm[ as.character( unlist(genes[1,1:2]) ), 1:90 ] )
  rownames(exprMatrix) <- as.character( unlist(genes[1,1:2]) )
  if( scale ){
    exprMatrix <- scale(t(exprMatrix))
    exprMatrix.m <- melt(exprMatrix)
  } else if( log ){
    exprMatrix <- log10( exprMatrix + 1 )
    exprMatrix.m <- melt(exprMatrix)
    colnames(exprMatrix.m) <- c("Var2", "Var1", "value")
  } else{
    exprMatrix.m <- melt(exprMatrix)
    colnames(exprMatrix.m) <- c("Var2", "Var1", "value")
  }

  # merge in stage info
  plotData <- merge(exprMatrix.m, rnaseqSampleInfo, by.x = c("Var1"), by.y = c("sampleName") )
  return(plotData)
}

#' plotExprByStage
#' Plot gene expression as points coloured by genes.
#' 
#' Takes a row from the pairwiseCor data.frame and retrieves the expression data.
#'    Then plots the expression data with stage on the x-axis and 
#'    expression value on the y-axis. The individual samples are plotted as points
#'    coloured by gene.
#'
#' @param genes data.frame, expects a row from the pairwiseCor data.frame
#' @param log logical, whether to log the tpms first
#' @param scale logical, whether to center and scale the tpms
#'
#' @return plot, ggplot2 object
#'
plotExprByStage <- function( genes, log = FALSE, scale = TRUE, size = 0.8 ){
  plotData <- getExprData( genes, log = log, scale = scale  )
  if( scale ){
    y_label <- "Expression (TPM - Mean Centered and SD scaled)"
  } else if( log ){
    y_label <- "Expression (log10 TPM)"
  } else{
    y_label <- "Expression (TPM)"
  }
  plot <- ggplot( data = plotData ) + 
    geom_point( aes( x = stageName, y = value, colour = Var2 ), size = size ) +
    guides( colour = guide_legend(title = "Genes") ) + 
    scale_colour_manual( values = c("firebrick1", "steelblue3"), labels = as.character( unlist(genes[1,c("gene1Name", "gene2Name")]) )) + 
    labs( x = "Stage", y = y_label,
          title = "Expression of paralogous genes over development" ) + 
    theme_minimal() + theme( axis.text.x = element_text(angle=45, hjust = 1) )
  return(plot)
}

#' make_scatterplot
#' Creates a scatterplot of the expression values of one gene against another
#' 
#' Takes a row from the pairwiseCor data.frame and retrieves the expression data.
#'    Then plots the expression values for gene1 against those for gene2
#'
#' @param genes data.frame, expects a row from the pairwiseCor data.frame
#'
#' @return plot, ggplot2 object
#'
make_scatterplot <- function( genes ){
  plotData <- getExprData( genes, log = FALSE, scale = FALSE )
  pointsData <- dcast( plotData, Var1 + stageName ~ Var2, value.var = "value" )
  colnames(pointsData) <- c("sampleName", "stageName", "gene1", "gene2")
  scatterPlot <- ggplot( data = pointsData, 
                         aes( x = gene1, y = gene2, colour = stageName ) ) + 
    geom_point() + 
    scale_color_manual( values = colourPalette ) +
    labs( x = genes$gene1Name[1], y = genes$gene2Name[1] ) + 
    theme_minimal()
    
  return(scatterPlot)
}
```

```{r bottom10_top10_together, include=TRUE}
corThreshold <- 0.9
highlyCor <- pairwiseCor[ pairwiseCor$CorCoeff > corThreshold & !is.na(pairwiseCor$CorCoeff), ]
highlyCor <- highlyCor[ order(highlyCor$CorCoeff, decreasing = TRUE), ]

corThreshold <- -0.5
negCor <- pairwiseCor[ pairwiseCor$CorCoeff < corThreshold & !is.na(pairwiseCor$CorCoeff), ]
negCor <- negCor[ order(negCor$CorCoeff), ]

top10_bottom10 <- rbind( highlyCor[1:10,], negCor[1:10,] )

top10_bottom10ExprData <- 
  do.call( rbind,
           lapply( split( top10_bottom10, rownames(top10_bottom10) ),
                    getExprData,
                    log = TRUE, scale = FALSE ) )
# make a df of coeff and gene names to use for ordering
genesCor <- data.frame( 
  geneIds = c( as.character(top10_bottom10$gene1), as.character(top10_bottom10$gene2) ),
  CorCoeff = rep(top10_bottom10$CorCoeff, 2)
)
geneNamestmp = c(as.character(top10_bottom10$gene1Name),as.character(top10_bottom10$gene2Name) )
geneNamestmp[ geneNamestmp == "" ] <- as.character( genesCor$geneIds[ geneNamestmp == "" ] )
genesCor$geneNames <- geneNamestmp

genesCor <- genesCor[ order( genesCor$CorCoeff, -xtfrm( genesCor$geneNames ) ), ]
# set levels of factor
genesCor$geneIds <- factor( genesCor$geneIds,
                            levels = genesCor$geneIds )
genesCor$geneNames <- factor( genesCor$geneNames,
                            levels = genesCor$geneNames )

# rorder genes factor (Var2)
top10_bottom10ExprData$Var2 <- factor( top10_bottom10ExprData$Var2,
                                       levels = levels(genesCor$geneIds) )
 
top10_bottom10Heatmap <- ggplot(data = top10_bottom10ExprData) + 
    geom_raster( aes( y = Var2, x = stageName, fill = value ) ) + 
    scale_y_discrete( labels = genesCor$geneNames ) + 
    scale_fill_gradientn( colours = c("blue", "yellow", "red") ) + 
    theme_void() + theme( legend.position="bottom",
                          legend.title = element_text(colour="black", angle = 0, debug = FALSE),
                          axis.text.y = element_text(colour="black", angle = 0, debug = FALSE, size = 6) )
postscript(file = file.path(rootPath, 'plots', 'Fig.6b.eps'),
           width = 3, height = 4.5, paper = 'special', horizontal = FALSE)
print(top10_bottom10Heatmap)
dev.off()
```

### Fig6c-f
#### scatterplots/point based expression profiles

```{r ckm_exprPlots, include=TRUE}
ckm_genes <- highlyCor[ grepl("ckm[ab]", highlyCor$gene1Name ), ]
ckm_plot <- plotExprByStage( ckm_genes, 
                              log = FALSE, scale = FALSE )
ckm_plot <- ckm_plot + theme( plot.title = element_blank(),
                              axis.text = element_text(colour="black", angle = 0, debug = FALSE, size = 6),
                              axis.title = element_text(colour="black", angle = 0, debug = FALSE, size = 7),
                              legend.text = element_text(colour="black", angle = 0, debug = FALSE, size = 6),
                              legend.title = element_text(colour="black", angle = 0, debug = FALSE, size = 7)
                              )

postscript(file = file.path(rootPath, 'plots', 'Fig.6c.eps'),
           width = 4, height = 3, paper = 'special', horizontal = FALSE)
print(ckm_plot)
dev.off()

```

```{r ckm_scatterplot, include=TRUE}
ckm_scatterplot <- make_scatterplot( ckm_genes )

ckm_scatterplot <- ckm_scatterplot + 
  theme( plot.title = element_blank(),
         axis.text = element_text(colour="black", angle = 0, debug = FALSE, size = 12),
         axis.title = element_text(colour="black", angle = 0, debug = FALSE, size = 14),
         legend.text = element_text(colour="black", angle = 0, debug = FALSE, size = 12),
         legend.title = element_text(colour="black", angle = 0, debug = FALSE, size = 14)
  )

postscript(file = file.path(rootPath, 'plots', 'Fig.6d.eps'),
           width = 8, height = 6, paper = 'special', horizontal = FALSE)
print(ckm_scatterplot)
dev.off()

```


```{r plot_as_linegraphs, include = TRUE}
impdh1_genes <- negCor[ grepl("impdh1", negCor$gene1Name ), ]
impdh1_plot <- plotExprByStage( impdh1_genes, 
                              log = FALSE, scale = FALSE )
impdh1_plot <- impdh1_plot + theme( plot.title = element_blank(),
                              axis.text = element_text(colour="black", angle = 0, debug = FALSE, size = 6),
                              axis.title = element_text(colour="black", angle = 0, debug = FALSE, size = 7),
                              legend.text = element_text(colour="black", angle = 0, debug = FALSE, size = 6),
                              legend.title = element_text(colour="black", angle = 0, debug = FALSE, size = 7)
                              )

postscript(file = file.path(rootPath, 'plots', 'Fig.6e.eps'),
           width = 4, height = 3, paper = 'special', horizontal = FALSE)
print(impdh1_plot)
dev.off()


```

```{r impdh1_scatterplot, include=TRUE}
impdh1_scatterplot <- make_scatterplot( impdh1_genes )

impdh1_scatterplot <- impdh1_scatterplot + 
  theme( plot.title = element_blank(),
         axis.text = element_text(colour="black", angle = 0, debug = FALSE, size = 12),
         axis.title = element_text(colour="black", angle = 0, debug = FALSE, size = 14),
         legend.text = element_text(colour="black", angle = 0, debug = FALSE, size = 12),
         legend.title = element_text(colour="black", angle = 0, debug = FALSE, size = 14)
  )

postscript(file = file.path(rootPath, 'plots', 'Fig.6f.eps'),
           width = 8, height = 6, paper = 'special', horizontal = FALSE)
print(impdh1_scatterplot)
dev.off()

```

```{r loadDETCTData}
detctDataFile <- file.path(rootPath, 'dataFiles', 'detct', 'DESeq.zfs.detct.grcz10.RData')
# load from file if it exists
if( file.exists(detctDataFile) ){
  load(detctDataFile)
} else {
  dataFile <- file.path(rootPath, 'dataFiles', 'detct', 'zfs-detct-grcz10.tsv')
  if( !file.exists(dataFile) ){
    stop("DETCT counts data file is not present! Please download from figshare. See README.")
  }
  detctData <- read.table(dataFile, sep="\t", header=TRUE, quote = "\"",
                     comment.char = "%")
  rownames(detctData) <- paste(detctData[,1], detctData[,2], detctData[,3], detctData[,5], sep=":")
  countData <- detctData[ , grepl("zmp.*count", colnames(detctData) ) &
                            !grepl("normalised", colnames(detctData) ) ]
  colnames(countData) <- gsub(".count", "", colnames(countData) )

  # sample Info
  detctSampleInfoFile <- file.path(rootPath, 'dataFiles', 'detct', 'zfs-detct-sampleInfo.tsv')
  detctSampleInfo <- read.table(detctSampleInfoFile, sep="\t", header=TRUE,
                                colClasses = c('character', 'character', 'character', 
                                          'factor', 'factor', 'factor', 'character' ) )
  rownames(detctSampleInfo) <- detctSampleInfo$sample
  
  # make colourGroup
  stageGroupNames <- c("pre-ZGA", "Gastrula", "Somitogenesis", "Prim-stages", "2-5dpf")
  colourGroupNames <- 
    c(paste0(stageGroupNames[1], '-', 1:4),
      paste0(stageGroupNames[2], '-', 1:4),
      paste0(stageGroupNames[3], '-', 1:3),
      paste0(stageGroupNames[4], '-', 1:3),
      paste0(stageGroupNames[5], '-', 1:4) )
  names(colourGroupNames) <- levels(detctSampleInfo$condition)
  colourGroup <- character( length = nrow(detctSampleInfo) )
  for( i in seq_len(length(colourGroupNames)) ){
    colourGroup[ detctSampleInfo$condition == names(colourGroupNames)[i] ] <- colourGroupNames[i]
  }
  detctSampleInfo$colourGroup <- factor( colourGroup,
                                          levels = unique(colourGroup) )
  detctSampleInfo$stageGroup <- 
    factor( gsub("-[1-5]$", "", colourGroup),
            levels = c("pre-ZGA", "Gastrula", "Somitogenesis", "Prim-stages", "2-5dpf") )
  
  # order by countData column names
  detctSampleInfo <- detctSampleInfo[ colnames(countData), ]
  # set levels of stageName
  detctSampleInfo$stageName <- factor( detctSampleInfo$stageName,
                                  levels = unique(detctSampleInfo$stageName) )
  # relabel colnames with sample names
  colnames(countData) <- detctSampleInfo$sampleName
  colnames(countData) <- 
    gsub(" ", "-", colnames(countData))
  # row names of sample info must match count data column names
  rownames(detctSampleInfo) <- detctSampleInfo$sampleName
  
  # make DESeq object and do vst transform
  detctDESeqDataSet <- DESeqDataSetFromMatrix(countData, detctSampleInfo, design = ~ condition)
  featureData <- detctData[ , !grepl("count", colnames(detctData)) | grepl("3..end.read.count", colnames(detctData)) ]
  mcols(detctDESeqDataSet) <- DataFrame(mcols(detctDESeqDataSet), 
                                        region = rownames(featureData),
                                        featureData
                                        )
  detctDESeqDataSet <- estimateSizeFactors(detctDESeqDataSet)
  detctDESeqDataSetVst <- varianceStabilizingTransformation(detctDESeqDataSet, blind=TRUE)
  
  # save objects to file for reloading
  save(detctData, detctSampleInfo, detctDESeqDataSet, detctDESeqDataSetVst, file=detctDataFile)
}

```

```{r reads_mapped_DETCT}
# DETCT data
# This data comes from running samtools flagstat on each bam file and then selecting the entry for properly paired reads
# e.g. grep properly $sample.markdup.flagstat.txt | awk '{ print "'$sample'", $1 }'
detctReadDataFile <- file.path(rootPath, 'dataFiles', 'detct', 'zfs-detct.read-pairs-mapped.tsv' )
detctReadData <- read.table(file=detctReadDataFile, sep="\t", header=FALSE)
colnames(detctReadData) <- c('sample', 'value')
sampleType <- rep('DETCT single', nrow(detctReadData))
sampleType[grepl('pool', detctReadData$sample)] <- 'DETCT pool'
detctReadData$sampleType <- factor( sampleType,
                                   levels = c('RNA-Seq', 'DETCT single', 'DETCT pool') )
detctReadDataMerged <- merge(detctReadData, detctSampleInfo)
```

```{r detct_genes_detected, eval=FALSE}
detctCounts <- counts(detctDESeqDataSet, normalized = TRUE)
countThreshold <- 5
# collect data on how many genes are detected in each sample
# Each gene is potentially represented by multiple regions
# Count as detected if any of the regions for a gene is above threshold
detctGenesDetectedBySampleList <- vector('list', length = nlevels(detctData$e86.Ensembl.Gene.ID) - 1 )
j <- 1
for (gene in levels(detctData$e86.Ensembl.Gene.ID) ) {
  if (gene == "-") {
    next
  }
  counts <- detctCounts[rownames(detctData)[ detctData$e86.Ensembl.Gene.ID == gene ], , drop = FALSE]
  aboveThreshold <- counts >= countThreshold
  aboveThresholdList <- split.data.frame(aboveThreshold, rownames(aboveThreshold))
  detctGenesDetectedBySampleList[[j]] <- Reduce('|', aboveThresholdList)
  j <- j + 1
}
detctGenesDetectedBySampleByGene <- do.call(rbind, detctGenesDetectedBySampleList)
detctGenesDetectedBySample <- melt(colSums(detctGenesDetectedBySampleByGene))
detctGenesDetected <- data.frame(
  sampleName = rownames(detctGenesDetectedBySample),
  sampleType = rep('DETCT', nrow(detctGenesDetectedBySample) ),
  threshold = rep(countThreshold, nrow(detctGenesDetectedBySample)),
  genes = detctGenesDetectedBySample$value
)
detctGDData <- merge(detctGenesDetected, detctSampleInfo )

```

### Figure 1-3

#### DETCT Sample QC plot

```{r fig1-3, include=TRUE}
# create sample correlation matrix
detctSampleCor <- cor(counts(detctDESeqDataSet, normalized=TRUE))
# detctSampleCor <- cor(counts(detctDESeqDataSet, normalized=TRUE)[, grepl('pool', colnames(counts(detctDESeqDataSet)))])
# detctSampleCor <- cor(counts(detctDESeqDataSet, normalized=TRUE)[, !grepl('pool', colnames(counts(detctDESeqDataSet)))])

# melt for ggplot
detctSampleCor.m <- melt(detctSampleCor)
# reverse levels of y axis variable so that it plots sensibly
detctSampleCor.m$Var2 <- factor( detctSampleCor.m$Var2,
                            levels = rev(levels(detctSampleCor.m$Var2))
  )
# plot correlation matrix
detctSampleCorHeatmap <- ggplot(data = detctSampleCor.m) + 
  geom_tile( aes( x = Var1, y = Var2, fill = value ) ) + 
  scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                        guide = guide_colorbar(title = "Correlation\nCoefficient\n(Pearson)"),
                        limits = c(0,1) ) + 
  theme_void() + theme( legend.position="right",
                        legend.title = element_text(colour='black' ),
                        axis.text.x = element_text(colour='black', angle = 90, 
                                                   size = 0.5, hjust = 1, debug = FALSE ) )

plotList <- add_to_plot_list( plotList, 
                              detctSampleCorHeatmap, file.path(rootPath, 'plots', 'Figure.1-3.pdf') )

print(detctSampleCorHeatmap)

# Spearman
detctSampleCor_spearman <- cor(counts(detctDESeqDataSet, normalized=TRUE), method = 'spearman')
# melt for ggplot
detctSampleCor_spearman.m <- melt(detctSampleCor_spearman)
# reverse levels of y axis variable so that it plots sensibly
detctSampleCor_spearman.m$Var2 <- factor( detctSampleCor_spearman.m$Var2,
                            levels = rev(levels(detctSampleCor_spearman.m$Var2))
  )
# plot correlation matrix
detctSampleCor_spearman_heatmap <- ggplot(data = detctSampleCor_spearman.m) + 
  geom_tile( aes( x = Var1, y = Var2, fill = value ) ) + 
  scale_fill_gradientn( colours = c("blue", "yellow", "red"),
                        guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)"),
                        limits = c(0,1) ) + 
  theme_void() + theme( legend.position="right",
                        legend.title = element_text(colour='black' ),
                        axis.text.x = element_text(colour='black', angle = 90, 
                                                   size = 0.5, hjust = 1, debug = FALSE ) )
print(detctSampleCor_spearman_heatmap)

pdf(file.path(rootPath, 'plots', 'Figure.1-3.spearman.pdf'))
print(detctSampleCor_spearman_heatmap)
dev.off()

# how it looks to those with deuteranopia
ggplot(data = detctSampleCor_spearman.m) + 
  geom_tile( aes( x = Var1, y = Var2, fill = value ) ) + 
  scale_fill_gradientn( colours = dichromat(c("blue", "yellow", "red")),
                        guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)"),
                        limits = c(0,1) ) + 
  theme_void() + theme( legend.position="right",
                        legend.title = element_text(colour='black' ),
                        axis.text.x = element_text(colour='black', angle = 90, 
                                                   size = 0.5, hjust = 1, debug = FALSE ) )

# use viridis colour scheme
pdf(file.path(rootPath, 'plots', 'Figure.1-3.spearman.viridis.pdf'))
ggplot(data = detctSampleCor_spearman.m) + 
  geom_tile( aes( x = Var1, y = Var2, fill = value ) ) + 
  scale_fill_viridis( guide = guide_colorbar(title = "Correlation\nCoefficient\n(Spearman)"),
                        limits = c(0,1) ) + 
  theme_void() + theme( legend.position="right",
                        legend.title = element_text(colour='black' ),
                        axis.text.x = element_text(colour='black', angle = 90, 
                                                   size = 0.5, hjust = 1, debug = FALSE ) )
dev.off()

```

### Figure 1-4

#### DETCT PCA

```{r detct_pca_all_regions}
detctpcaObj <- runPCA( detctDESeqDataSet, detctDESeqDataSetVst, nrow(detctDESeqDataSetVst) )
detctpcaPlotList <- detctpcaObj$plots
detctPCDataList <- detctpcaObj$PCData
detctMatrixPlotList <- PCA_matrixPlot( detctPCDataList, detctpcaObj$pca, 
                                       detctDESeqDataSetVst, numGenes = 100 )

ggsave(file.path(rootPath, 'plots', 'Figure.1-4.pdf'), 
       width = 20, height = 20, 
       marrangeGrob(detctMatrixPlotList, nrow = 6, ncol = 6) )
```

```{r print_detct_pca, include=TRUE}
grid.newpage()
grid.draw( 
  arrangeGrob( grobs = detctMatrixPlotList,
               nrow = 6, ncol = 6
              )
)
dev.off()
```

### Fig.6C

#### Count bar chart by Stage

```{r get_example_region}
pdlim5b_counts <- counts(detctDESeqDataSet, normalized = TRUE)[ mcols(detctDESeqDataSet)$e86.Ensembl.Gene.ID == "ENSDARG00000027600", ]
# one of the regions is associated with the same 3' end as End 2 
# but is the exon before.
# exclude it
pdlim5b_counts <- pdlim5b_counts[c(1,2,4),]
# label ends
rownames(pdlim5b_counts) <- c("End 1", "End 2", "End 3")

# calc mean per stage
meanData <- do.call(rbind,
                    lapply( levels( colData(detctDESeqDataSet)$stageName ),
                            function(stage, counts){
                              # get columns for stage
                              countSubset <- counts[ , grepl(stage, colnames(counts)) ]
                              df <- data.frame( 
                                End = factor( rownames(countSubset),
                                              levels = rownames(countSubset) ),
                                Stage = rep(stage,nrow(countSubset)),
                                meanCounts = rowMeans( countSubset ),
                                sd = rowSds( countSubset )
                              ) 
                              df$lower = df$meanCounts - df$sd
                              df$lower[ df$lower < 0 ] <- 0
                              df$upper = df$meanCounts + df$sd
                              return(df)
                            },
                            pdlim5b_counts
                    )
)

```

```{r barPlot, include=TRUE}
barPlot <- ggplot( data = meanData, aes( x = Stage, y = meanCounts, fill = End ) ) +
  geom_bar( stat="identity", position = "dodge" ) + 
  geom_errorbar( aes(ymin = lower, ymax = upper, colour = End ), position="dodge" ) +
  labs( y = "Mean Normalised Counts" ) + 
  scale_fill_brewer(type="qual", palette = "Set2") +
  scale_colour_brewer(type="qual", palette = "Set2") +
  theme_minimal() + theme( axis.text.x = element_blank() )

plotList <- add_to_plot_list( 
  plotList,
  barPlot,
  file.path(rootPath, 'plots', 'Figure.6c.pdf')
)

print(barPlot)
```


```{r print_plots_to_file }
for( plotInfo in plotList ){
  pdf(file=plotInfo$file)
  print(plotInfo$plot)
  dev.off()
}
```

## Session Info

```{r sessionInfo, echo=FALSE, results='markup', include=TRUE}
sessionInfo()

save.image(file=file.path(rootPath, 'workspace.RData'))
```
